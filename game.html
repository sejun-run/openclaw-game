<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#1a1a2e">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <title>ì„œë²„ ë””íœìŠ¤ - ì¸í”„ë¼ ì¹´ë“œê²Œì„</title>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(() => {});
    }
  </script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      min-height: 100%;
      margin: 0;
      padding: 0;
    }
    
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      font-family: 'Segoe UI', sans-serif;
      -webkit-overflow-scrolling: touch;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* ë©”ì¸ ì»¨í…Œì´ë„ˆ */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px;
    }

    /* ê²Œì„ ëª¨ë“œ: ì „ì²´ í™”ë©´ ê³ ì • */
    body.game-mode {
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      height: 100dvh;
    }

    body.game-mode .container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      max-width: 100%;
      padding: 3px;
      padding-top: env(safe-area-inset-top, 3px);
      padding-bottom: env(safe-area-inset-bottom, 3px);
      display: flex;
      flex-direction: column;
    }

    header {
      text-align: center;
      padding: 15px 0;
      margin-bottom: 15px;
    }

    body.game-mode header { display: none; }

    h1 {
      font-size: 2.2em;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 5px;
    }

    .subtitle { color: #888; font-size: 1em; }

    /* íƒ­ */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    body.game-mode .tabs { display: none; }

    .tab-btn {
      padding: 12px 30px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 25px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1em;
    }

    .tab-btn:hover, .tab-btn.active {
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      color: #000;
      border-color: transparent;
    }

    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* ========== ë„ê° ìŠ¤íƒ€ì¼ ========== */
    .filters {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
    }

    .filter-btn {
      padding: 8px 16px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 20px;
      color: #aaa;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.3s;
    }

    .filter-btn:hover, .filter-btn.active {
      background: rgba(0, 217, 255, 0.2);
      border-color: #00d9ff;
      color: #fff;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 15px;
    }

    .card-item {
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
    }

    .card-item:hover {
      transform: translateY(-5px);
      border-color: #00d9ff;
      box-shadow: 0 10px 30px rgba(0, 217, 255, 0.3);
    }

    .card-item .icon { font-size: 2.5em; text-align: center; margin-bottom: 10px; }
    .card-item .name { font-weight: bold; text-align: center; margin-bottom: 5px; }
    .card-item .category { font-size: 0.8em; color: #888; text-align: center; }

    .card-item .stats {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 10px;
      font-size: 0.85em;
    }

    .card-item .cost { color: #3498db; }
    .card-item .atk { color: #e74c3c; }
    .card-item .hp { color: #2ecc71; }

    /* ì¹´ë“œ ìƒì„¸ ëª¨ë‹¬ */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .modal-overlay.active { display: flex; }

    .modal-content {
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border-radius: 15px;
      padding: 25px;
      max-width: 400px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-content .icon { font-size: 4em; text-align: center; margin-bottom: 15px; }
    .modal-content .name { font-size: 1.5em; font-weight: bold; text-align: center; }
    .modal-content .category { color: #888; text-align: center; margin-bottom: 15px; }

    .modal-content .stats-row {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .modal-content .stat-box {
      background: rgba(0,0,0,0.3);
      padding: 10px 20px;
      border-radius: 10px;
      text-align: center;
    }

    .modal-content .stat-value { font-size: 1.3em; font-weight: bold; }
    .modal-content .stat-label { font-size: 0.75em; color: #888; }

    .modal-content .description {
      color: #ccc;
      line-height: 1.6;
      margin-bottom: 15px;
    }

    .modal-content .effect {
      background: rgba(0, 217, 255, 0.1);
      border-left: 3px solid #00d9ff;
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 0 8px 8px 0;
    }

    .modal-content .services {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-bottom: 20px;
    }

    .modal-content .service-tag {
      background: rgba(255,255,255,0.1);
      padding: 5px 12px;
      border-radius: 15px;
      font-size: 0.8em;
    }

    .modal-content .close-btn {
      display: block;
      width: 100%;
      padding: 12px;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      border: none;
      border-radius: 25px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
    }

    /* ========== ê²Œì„ ìŠ¤íƒ€ì¼ ========== */
    .game-start {
      text-align: center;
      padding: 40px 20px;
    }

    .game-start h2 { font-size: 1.8em; margin-bottom: 15px; color: #00d9ff; }
    .game-start p { color: #888; margin-bottom: 20px; }

    .difficulty-btns {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .diff-btn {
      padding: 20px 30px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 15px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s;
    }

    .diff-btn:hover {
      border-color: #00d9ff;
      background: rgba(0, 217, 255, 0.1);
    }

    .diff-btn h3 { margin-bottom: 5px; }
    .diff-btn p { font-size: 0.85em; color: #888; margin: 0; }

    /* ì „íˆ¬ í™”ë©´ */
    .battle-screen {
      display: none;
      flex: 1;
      flex-direction: column;
      gap: 3px;
      min-height: 0;
      overflow: hidden;
    }

    body.game-mode .battle-screen { display: flex; }

    .enemy-area {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .player-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 3px;
      min-height: 0;
    }

    .status-bar {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 4px 8px;
      background: rgba(0,0,0,0.4);
      border-radius: 6px;
    }

    .player-info {
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .player-icon { font-size: 1em; }
    .player-name { font-weight: bold; font-size: 0.75em; }
    .enemy-area .player-name { color: #ff6b6b; }
    .player-area .player-name { color: #4ecdc4; }

    .hp-bar {
      width: 90px;
      height: 14px;
      background: #333;
      border-radius: 7px;
      overflow: hidden;
      position: relative;
    }

    .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #27ae60, #2ecc71);
      transition: width 0.3s;
    }

    .hp-fill.low { background: linear-gradient(90deg, #c0392b, #e74c3c); }

    .hp-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.6em;
      font-weight: bold;
      text-shadow: 1px 1px 2px #000;
    }

    .mana-display {
      display: flex;
      align-items: center;
      gap: 4px;
      background: rgba(0, 150, 255, 0.3);
      padding: 3px 8px;
      border-radius: 10px;
      font-weight: bold;
      font-size: 0.8em;
    }

    .battle-field {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
      min-height: 50px;
      padding: 5px;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
    }

    .field-placeholder { color: #555; font-size: 0.8em; }

    .battle-divider {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      padding: 2px 0;
    }

    .divider-line {
      flex: 1;
      height: 1px;
      background: linear-gradient(90deg, transparent, #444, transparent);
    }

    .vs-badge {
      padding: 2px 10px;
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border-radius: 8px;
      font-size: 0.65em;
      font-weight: bold;
      margin: 0 8px;
    }

    /* í•¸ë“œ */
    .hand-area {
      flex: 0 0 auto;
      height: 75px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      padding-bottom: 3px;
    }

    .hand {
      display: flex;
      justify-content: center;
    }

    .hand-card {
      width: 55px;
      height: 70px;
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border: 2px solid #444;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0 -10px;
      transform-origin: bottom center;
    }

    .hand-card:hover {
      transform: translateY(-25px) scale(1.1);
      z-index: 100;
      border-color: #00d9ff;
      box-shadow: 0 15px 40px rgba(0, 217, 255, 0.4);
    }

    .hand-card.selected {
      transform: translateY(-35px) scale(1.15);
      z-index: 101;
      border-color: #00ff88;
      box-shadow: 0 20px 50px rgba(0, 255, 136, 0.5);
    }

    .hand-card.disabled { opacity: 0.5; }
    .hand-card.dragging { opacity: 0.3; }
    
    /* êµ¬ë§¤ ê°€ëŠ¥í•œ ì¹´ë“œ í•˜ì´ë¼ì´íŠ¸ */
    .hand-card.playable {
      border-color: #00ff88;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
    }

    .hand-card .cost {
      position: absolute;
      top: -6px;
      right: -6px;
      width: 18px;
      height: 18px;
      background: linear-gradient(135deg, #3498db, #2980b9);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.65em;
      font-weight: bold;
      border: 2px solid #fff;
    }

    .hand-card .icon { font-size: 1.4em; }
    .hand-card .name { font-size: 0.5em; margin-top: 2px; }

    .hand-card .card-stats {
      display: flex;
      gap: 5px;
      font-size: 0.5em;
      margin-top: 2px;
    }

    /* í•„ë“œ ì¹´ë“œ */
    .field-card {
      width: 50px;
      height: 60px;
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border: 2px solid #555;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 5px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }

    .field-card:hover {
      border-color: #00d9ff;
      transform: scale(1.05);
    }

    .field-card.can-attack {
      border-color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 8px rgba(0, 255, 136, 0.5); }
      50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
    }

    @keyframes floatUp {
      0% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px) rotate(-2deg); }
      75% { transform: translateX(5px) rotate(2deg); }
    }

    .field-card.attacking {
      animation: shake 0.3s ease-in-out;
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 5px rgba(0, 217, 255, 0.5); }
      50% { box-shadow: 0 0 20px rgba(0, 217, 255, 1); }
    }

    .field-card.synergy {
      animation: glow 2s infinite;
      border-color: #00d9ff;
    }

    /* ê³µê²© ëŒ€ìƒ í•˜ì´ë¼ì´íŠ¸ */
    .field-card.attack-target,
    .hp-bar.attack-target {
      animation: targetPulse 0.5s infinite;
      border-color: #e74c3c !important;
    }

    @keyframes targetPulse {
      0%, 100% { box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
      50% { box-shadow: 0 0 25px rgba(231, 76, 60, 1); }
    }

    .field-card .icon { font-size: 1.4em; line-height: 1; }
    .field-card .name { 
      font-size: 0.4em; 
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 1px;
      opacity: 0.8;
    }

    .field-card .card-atk {
      position: absolute;
      bottom: -4px;
      left: -4px;
      width: 18px;
      height: 18px;
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border-radius: 50%;
      font-size: 0.55em;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #1a1a2e;
    }

    .field-card .card-hp {
      position: absolute;
      bottom: -4px;
      right: -4px;
      width: 18px;
      height: 18px;
      background: linear-gradient(135deg, #27ae60, #1e8449);
      border-radius: 50%;
      font-size: 0.55em;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #1a1a2e;
    }

    /* ì»¨íŠ¸ë¡¤ ë²„íŠ¼ */
    .controls {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .btn {
      padding: 6px 16px;
      border: none;
      border-radius: 15px;
      font-weight: bold;
      font-size: 0.8em;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #00d9ff, #00ff88);
      color: #000;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: #fff;
    }

    .btn-back {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .btn:active { transform: scale(0.95); }

    /* ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      opacity: 0.9;
      transform: translate(-50%, -50%) scale(1.1);
    }

    .drag-ghost .hand-card {
      margin: 0;
      box-shadow: 0 20px 60px rgba(0, 217, 255, 0.6);
      border-color: #00d9ff;
    }

    .battle-field.drop-target {
      background: rgba(0, 255, 136, 0.2);
      border: 2px dashed #00ff88;
    }

    /* ë°°í‹€ ë¡œê·¸ */
    .battle-log {
      position: fixed;
      top: 50%;
      left: 5px;
      transform: translateY(-50%);
      background: rgba(0,0,0,0.7);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 0.55em;
      max-width: 100px;
      max-height: 60px;
      overflow-y: auto;
      z-index: 50;
    }

    .log-entry { padding: 2px 0; color: #aaa; }
    .log-entry.damage { color: #e74c3c; }
    .log-entry.info { color: #00d9ff; }

    /* ê²Œì„ ì˜¤ë²„ */
    .game-over {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    .game-over.active { display: flex; }
    .game-over h2 { font-size: 2.5em; margin-bottom: 20px; }
    .game-over.win h2 { color: #00ff88; }
    .game-over.lose h2 { color: #e74c3c; }
    .game-over p { color: #888; margin-bottom: 30px; }

    /* ë°˜ì‘í˜• */
    @media (max-width: 600px) {
      h1 { font-size: 1.8em; }
      .card-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; }
      .hand-card { width: 60px; height: 80px; margin: 0 -10px; }
      .hand-card .icon { font-size: 1.6em; }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ğŸƒ ì„œë²„ ë””íœìŠ¤</h1>
      <p class="subtitle">ì¸í”„ë¼ ì¹´ë“œê²Œì„ìœ¼ë¡œ ë°°ìš°ëŠ” í´ë¼ìš°ë“œ ì•„í‚¤í…ì²˜</p>
    </header>

    <div class="tabs">
      <button class="tab-btn active" data-tab="collection">ğŸ“š ì¹´ë“œ ë„ê°</button>
      <button class="tab-btn" data-tab="game">ğŸ® ê²Œì„í•˜ê¸°</button>
    </div>

    <!-- ë„ê° íƒ­ -->
    <div id="collection" class="tab-content active">
      <div class="filters">
        <button class="filter-btn active" data-filter="all">ì „ì²´</button>
        <button class="filter-btn" data-filter="computing">ğŸ–¥ï¸ ì»´í“¨íŒ…</button>
        <button class="filter-btn" data-filter="storage">ğŸ’¾ ìŠ¤í† ë¦¬ì§€</button>
        <button class="filter-btn" data-filter="database">ğŸ—„ï¸ DB</button>
        <button class="filter-btn" data-filter="network">ğŸŒ ë„¤íŠ¸ì›Œí¬</button>
        <button class="filter-btn" data-filter="security">ğŸ”’ ë³´ì•ˆ</button>
        <button class="filter-btn" data-filter="devops">âš™ï¸ DevOps</button>
        <button class="filter-btn" data-filter="monitoring">ğŸ“Š ëª¨ë‹ˆí„°ë§</button>
        <button class="filter-btn" data-filter="attack">ğŸ’¥ ê³µê²©</button>
      </div>
      <div class="card-grid" id="cardGrid"></div>
    </div>

    <!-- ê²Œì„ íƒ­ -->
    <div id="game" class="tab-content">
      <div class="game-start" id="gameStart">
        <h2>ğŸš€ ì„œë²„ë¥¼ ì§€ì¼œë¼!</h2>
        <p>ì¸í”„ë¼ ì¹´ë“œë¡œ ì„œë²„ë¥¼ êµ¬ì¶•í•˜ê³ , DDoS ê³µê²©ìœ¼ë¡œë¶€í„° ë°©ì–´í•˜ì„¸ìš”!</p>
        <div class="difficulty-btns">
          <div class="diff-btn" onclick="startGame('easy')">
            <h3>ğŸŸ¢ ì‰¬ì›€</h3>
            <p>ì…ë¬¸ììš©</p>
          </div>
          <div class="diff-btn" onclick="startGame('normal')">
            <h3>ğŸŸ¡ ë³´í†µ</h3>
            <p>ê¸°ë³¸</p>
          </div>
          <div class="diff-btn" onclick="startGame('hard')">
            <h3>ğŸ”´ ì–´ë ¤ì›€</h3>
            <p>ë„ì „!</p>
          </div>
        </div>
      </div>
    </div>

    <!-- ì „íˆ¬ í™”ë©´ -->
    <div class="battle-screen" id="battleScreen">
      <div class="enemy-area">
        <div class="status-bar">
          <div class="player-info">
            <span class="player-icon">ğŸ¤–</span>
            <span class="player-name">DDoS ë´‡</span>
            <div class="hp-bar" id="enemyHpBar">
              <div class="hp-fill" id="enemyHpFill"></div>
              <span class="hp-text" id="enemyHpText">100/100</span>
            </div>
          </div>
          <div class="mana-display">
            <span>âš¡</span>
            <span id="manaText">1/1</span>
          </div>
        </div>
        <div class="battle-field" id="enemyField">
          <span class="field-placeholder">ì  ì„œë²„</span>
        </div>
      </div>

      <div class="battle-divider">
        <div class="divider-line"></div>
        <span class="vs-badge">VS</span>
        <div class="divider-line"></div>
      </div>

      <div class="player-area">
        <div class="battle-field" id="playerField">
          <span class="field-placeholder">ì¹´ë“œë¥¼ ë°°ì¹˜í•˜ì„¸ìš”</span>
        </div>
        <div class="status-bar">
          <div class="player-info">
            <span class="player-icon">ğŸ‘¤</span>
            <span class="player-name">ë‚˜</span>
            <div class="hp-bar">
              <div class="hp-fill" id="playerHpFill"></div>
              <span class="hp-text" id="playerHpText">100/100</span>
            </div>
          </div>
          <div class="controls">
            <button class="btn btn-primary" id="endTurnBtn" onclick="endTurn()">í„´ ì¢…ë£Œ</button>
            <button class="btn btn-back" onclick="exitGame()">ë‚˜ê°€ê¸°</button>
          </div>
        </div>
        <div class="hand-area">
          <div class="hand" id="playerHand"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- ì¹´ë“œ ìƒì„¸ ëª¨ë‹¬ -->
  <div class="modal-overlay" id="modalOverlay" onclick="closeModal(event)">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="icon" id="modalIcon">ğŸ–¥ï¸</div>
      <div class="name" id="modalName">EC2</div>
      <div class="category" id="modalCategory">ì»´í“¨íŒ…</div>
      <div class="stats-row">
        <div class="stat-box">
          <div class="stat-value" id="modalCost">3</div>
          <div class="stat-label">ì½”ìŠ¤íŠ¸</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="modalHp">100</div>
          <div class="stat-label">HP</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="modalAtk">20</div>
          <div class="stat-label">ê³µê²©ë ¥</div>
        </div>
      </div>
      <div class="description" id="modalDesc">ì„¤ëª…</div>
      <div class="effect" id="modalEffect">ğŸ’¡ íš¨ê³¼</div>
      <div class="services" id="modalServices"></div>
      <button class="close-btn" onclick="closeModal()">ë‹«ê¸°</button>
    </div>
  </div>

  <!-- ê²Œì„ ì¤‘ ì¹´ë“œ ìƒì„¸ -->
  <div class="modal-overlay" id="gameCardModal" onclick="closeGameCardModal(event)">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="icon" id="gameCardIcon">ğŸ–¥ï¸</div>
      <div class="name" id="gameCardName">EC2</div>
      <div class="category" id="gameCardCategory">ì»´í“¨íŒ…</div>
      <div class="stats-row">
        <div class="stat-box">
          <div class="stat-value" id="gameCardCost">3</div>
          <div class="stat-label">ì½”ìŠ¤íŠ¸</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="gameCardHp">100</div>
          <div class="stat-label">HP</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="gameCardAtk">20</div>
          <div class="stat-label">ê³µê²©ë ¥</div>
        </div>
      </div>
      <div class="description" id="gameCardDesc">ì„¤ëª…</div>
      <div class="effect" id="gameCardEffect">ğŸ’¡ íš¨ê³¼</div>
      <div id="gameCardActions" style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;"></div>
    </div>
  </div>

  <!-- ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ -->
  <div class="drag-ghost" id="dragGhost" style="display: none;"></div>

  <!-- ë°°í‹€ ë¡œê·¸ -->
  <div class="battle-log" id="battleLog" style="display: none;">
    <div class="log-entry info">ê²Œì„ ì‹œì‘!</div>
  </div>

  <!-- ê²Œì„ ì˜¤ë²„ -->
  <div class="game-over" id="gameOver">
    <div>
      <h2 id="gameOverTitle">ìŠ¹ë¦¬!</h2>
      <p id="gameOverMsg">ìƒëŒ€ ì„œë²„ë¥¼ ë‹¤ìš´ì‹œì¼°ìŠµë‹ˆë‹¤!</p>
      <button class="btn btn-primary" onclick="restartGame()">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>
  </div>

  <script>
    // ì¹´ë“œ ë°ì´í„°
    const allCards = [
      { id: 'ec2', name: 'EC2', icon: 'ğŸ–¥ï¸', category: 'computing', cost: 3, hp: 100, attack: 20,
        desc: 'Elastic Compute Cloud. ê°€ìƒ ì„œë²„ì˜ ëŒ€ëª…ì‚¬. í•„ìš”í•  ë•Œ ë°”ë¡œ ìƒì„±í•˜ê³ , ì•ˆ ì“°ë©´ ì¢…ë£Œ. í´ë¼ìš°ë“œì˜ ê¸°ë³¸ ì»´í“¨íŒ… ë¦¬ì†ŒìŠ¤ì…ë‹ˆë‹¤.',
        effect: 'ê¸°ë³¸ ì„œë²„ ì¹´ë“œ. ì•ˆì •ì ì¸ HPë¡œ ì „ì„  ìœ ì§€ì— ì í•©.', services: ['AWS EC2', 'GCP Compute Engine', 'Azure VM'] },
      { id: 'lambda', name: 'Lambda', icon: 'Î»', category: 'computing', cost: 2, hp: 30, attack: 40,
        desc: 'ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜. ì„œë²„ ê´€ë¦¬ ì—†ì´ ì½”ë“œë§Œ ì‹¤í–‰. ì‚¬ìš©í•œ ë§Œí¼ë§Œ ê³¼ê¸ˆë˜ëŠ” ì´ë²¤íŠ¸ ê¸°ë°˜ ì»´í“¨íŒ….',
        effect: 'HPëŠ” ë‚®ì§€ë§Œ ê³µê²©ë ¥ì´ ë†’ìŒ. ì†ê³µì— ìœ ë¦¬.', services: ['AWS Lambda', 'GCP Cloud Functions', 'Azure Functions'] },
      { id: 'k8s', name: 'Kubernetes', icon: 'â˜¸ï¸', category: 'computing', cost: 5, hp: 150, attack: 30,
        desc: 'ì»¨í…Œì´ë„ˆ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ì˜ ì™•. ìˆ˜ì²œ ê°œì˜ ì»¨í…Œì´ë„ˆë¥¼ ìë™ìœ¼ë¡œ ë°°í¬, ìŠ¤ì¼€ì¼ë§, ê´€ë¦¬.',
        effect: 'ë†’ì€ HP. íŒŒê´´ë˜ì–´ë„ 50% í™•ë¥ ë¡œ Podê°€ ë¶€í™œ.', services: ['AWS EKS', 'GCP GKE', 'Azure AKS'] },
      { id: 'fargate', name: 'Fargate', icon: 'ğŸš€', category: 'computing', cost: 4, hp: 80, attack: 25,
        desc: 'ì„œë²„ë¦¬ìŠ¤ ì»¨í…Œì´ë„ˆ. EC2 ì¸ìŠ¤í„´ìŠ¤ ê´€ë¦¬ ì—†ì´ ì»¨í…Œì´ë„ˆ ì‹¤í–‰. K8së³´ë‹¤ ê°„í¸.',
        effect: 'ë°°ì¹˜ ì‹œ ì¦‰ì‹œ ê³µê²© ê°€ëŠ¥.', services: ['AWS Fargate', 'GCP Cloud Run'] },
      { id: 's3', name: 'S3', icon: 'ğŸª£', category: 'storage', cost: 2, hp: 200, attack: 0,
        desc: 'Simple Storage Service. ë¬´ì œí•œ ê°ì²´ ìŠ¤í† ë¦¬ì§€. 99.999999999% ë‚´êµ¬ì„±ì˜ ì „ì„¤.',
        effect: 'ê³µê²© ë¶ˆê°€. íŒŒê´´ ì‹œ ëª¨ë“  ì•„êµ° ì¹´ë“œ HP +20 íšŒë³µ.', services: ['AWS S3', 'GCP Cloud Storage', 'Azure Blob'] },
      { id: 'ebs', name: 'EBS', icon: 'ğŸ’¾', category: 'storage', cost: 2, hp: 60, attack: 10,
        desc: 'Elastic Block Store. EC2ì— ë¶™ì´ëŠ” SSD/HDD. ìŠ¤ëƒ…ìƒ·ìœ¼ë¡œ ë°±ì—… ê°€ëŠ¥.',
        effect: 'EC2ì™€ í•¨ê»˜ ë°°ì¹˜ ì‹œ EC2ì˜ HP +30.', services: ['AWS EBS', 'GCP Persistent Disk'] },
      { id: 'rds', name: 'RDS', icon: 'ğŸ—„ï¸', category: 'database', cost: 4, hp: 120, attack: 15,
        desc: 'Relational Database Service. MySQL, PostgreSQL, Oracle ë“± ê´€ë¦¬í˜• DB. ë°±ì—…, íŒ¨ì¹˜ ìë™í™”.',
        effect: 'ë†’ì€ HPë¡œ ì•ˆì •ì . ë§¤í„´ ìë™ HP +5 íšŒë³µ.', services: ['AWS RDS', 'GCP Cloud SQL', 'Azure SQL'] },
      { id: 'dynamodb', name: 'DynamoDB', icon: 'âš¡', category: 'database', cost: 3, hp: 70, attack: 25,
        desc: 'NoSQLì˜ ëíŒì™•. ë°€ë¦¬ì´ˆ ì§€ì—°ì‹œê°„, ë¬´í•œ ìŠ¤ì¼€ì¼. ì„œë²„ë¦¬ìŠ¤ì™€ ì°°ë–¡ê¶í•©.',
        effect: 'Lambdaì™€ í•¨ê»˜ ìˆìœ¼ë©´ ê³µê²©ë ¥ +15.', services: ['AWS DynamoDB', 'GCP Firestore'] },
      { id: 'redis', name: 'Redis', icon: 'ğŸ”´', category: 'database', cost: 3, hp: 50, attack: 35,
        desc: 'ì¸ë©”ëª¨ë¦¬ ìºì‹œì˜ ì™•. ë§ˆì´í¬ë¡œì´ˆ ì‘ë‹µì‹œê°„. ì„¸ì…˜, ìºì‹œ, ì‹¤ì‹œê°„ ë­í‚¹ì— í•„ìˆ˜.',
        effect: 'DB ì¹´ë“œ ì•ì— ë°°ì¹˜ ì‹œ ë°›ëŠ” ë°ë¯¸ì§€ 30% ê°ì†Œ.', services: ['AWS ElastiCache', 'GCP Memorystore'] },
      { id: 'elb', name: 'ELB', icon: 'âš–ï¸', category: 'network', cost: 3, hp: 80, attack: 10,
        desc: 'Elastic Load Balancer. íŠ¸ë˜í”½ì„ ì—¬ëŸ¬ ì„œë²„ì— ë¶„ì‚°. ê³ ê°€ìš©ì„±ì˜ í•µì‹¬.',
        effect: 'ì„œë²„ ì¹´ë“œ 2ê°œ ì´ìƒ ì‹œ ë°›ëŠ” ë°ë¯¸ì§€ ë¶„ì‚°.', services: ['AWS ALB/NLB', 'GCP Load Balancer'] },
      { id: 'cdn', name: 'CloudFront', icon: 'ğŸŒ', category: 'network', cost: 2, hp: 40, attack: 0,
        desc: 'CDN (Content Delivery Network). ì „ ì„¸ê³„ ì—£ì§€ ë¡œì¼€ì´ì…˜ì—ì„œ ì½˜í…ì¸  ìºì‹±. ë¹ ë¥¸ ì‘ë‹µì˜ ë¹„ê²°.',
        effect: 'íŠ¸ë˜í”½ ìŠ¤íŒŒì´í¬ ê³µê²© ë¬´íš¨í™”.', services: ['AWS CloudFront', 'GCP Cloud CDN', 'Cloudflare'] },
      { id: 'route53', name: 'Route 53', icon: 'ğŸ§­', category: 'network', cost: 2, hp: 50, attack: 5,
        desc: 'DNS ì„œë¹„ìŠ¤. ë„ë©”ì¸ ê´€ë¦¬, í—¬ìŠ¤ì²´í¬, ë¼ìš°íŒ… ì •ì±…. ì´ë¦„ì˜ ìœ ë˜ëŠ” DNS í¬íŠ¸ 53.',
        effect: 'í•„ë“œì— ìˆìœ¼ë©´ ëª¨ë“  ì•„êµ° ì¹´ë“œ ê³µê²© +5.', services: ['AWS Route 53', 'GCP Cloud DNS'] },
      { id: 'vpc', name: 'VPC', icon: 'ğŸ°', category: 'network', cost: 3, hp: 100, attack: 0,
        desc: 'Virtual Private Cloud. ë‚˜ë§Œì˜ ê°€ìƒ ë„¤íŠ¸ì›Œí¬. ì„œë¸Œë„·, ë³´ì•ˆê·¸ë£¹ìœ¼ë¡œ ì² ë²½ ë°©ì–´.',
        effect: 'ëª¨ë“  ì•„êµ°ì´ ë°›ëŠ” ë°ë¯¸ì§€ -5.', services: ['AWS VPC', 'GCP VPC', 'Azure VNet'] },
      { id: 'waf', name: 'WAF', icon: 'ğŸ›¡ï¸', category: 'security', cost: 3, hp: 60, attack: 0,
        desc: 'Web Application Firewall. SQL Injection, XSS ë“± ì›¹ ê³µê²© ì°¨ë‹¨. ë³´ì•ˆì˜ ìµœì „ì„ .',
        effect: 'SQL Injection, XSS ê³µê²© ì™„ì „ ë¬´íš¨í™”.', services: ['AWS WAF', 'GCP Cloud Armor'] },
      { id: 'iam', name: 'IAM', icon: 'ğŸ”‘', category: 'security', cost: 2, hp: 40, attack: 0,
        desc: 'Identity and Access Management. ëˆ„ê°€ ë¬´ì—‡ì„ í•  ìˆ˜ ìˆëŠ”ì§€ ì œì–´. ìµœì†Œ ê¶Œí•œ ì›ì¹™!',
        effect: 'ì ì˜ ê¶Œí•œ ìƒìŠ¹ ê³µê²© ë¬´íš¨í™”.', services: ['AWS IAM', 'GCP IAM', 'Azure AD'] },
      { id: 'ssl', name: 'SSL/TLS', icon: 'ğŸ”', category: 'security', cost: 1, hp: 20, attack: 0,
        desc: 'HTTPSì˜ í•µì‹¬. ë°ì´í„° ì•”í˜¸í™”ë¡œ ë„ì²­ ë°©ì§€. ì´ˆë¡ ìë¬¼ì‡ ì˜ ì •ì²´.',
        effect: 'ëª¨ë“  ì•„êµ°ì´ ë°›ëŠ” ë°ë¯¸ì§€ -5.', services: ['AWS ACM', "Let's Encrypt"] },
      { id: 'kms', name: 'KMS', icon: 'ğŸ—ï¸', category: 'security', cost: 2, hp: 30, attack: 0,
        desc: 'Key Management Service. ì•”í˜¸í™” í‚¤ ê´€ë¦¬. ë°ì´í„° ë³´í˜¸ì˜ í•µì‹¬.',
        effect: 'ë°ì´í„° ìœ ì¶œ ê³µê²© ë°ë¯¸ì§€ 50% ê°ì†Œ.', services: ['AWS KMS', 'GCP Cloud KMS'] },
      { id: 'cicd', name: 'CI/CD', icon: 'ğŸ”„', category: 'devops', cost: 2, hp: 40, attack: 15,
        desc: 'ì§€ì†ì  í†µí•©/ë°°í¬. ì½”ë“œ í‘¸ì‹œ â†’ ìë™ í…ŒìŠ¤íŠ¸ â†’ ìë™ ë°°í¬. DevOpsì˜ ê½ƒ.',
        effect: 'ë§¤í„´ ì¹´ë“œ 1ì¥ ì¶”ê°€ ë“œë¡œìš°.', services: ['GitHub Actions', 'GitLab CI', 'Jenkins'] },
      { id: 'terraform', name: 'Terraform', icon: 'ğŸ—ï¸', category: 'devops', cost: 3, hp: 50, attack: 20,
        desc: 'Infrastructure as Code. ì½”ë“œë¡œ ì¸í”„ë¼ ê´€ë¦¬. ì¬í˜„ ê°€ëŠ¥í•œ í™˜ê²½ êµ¬ì¶•.',
        effect: 'íŒŒê´´ ì‹œ ê°™ì€ ì¹´ë“œ 1ì¥ì„ í•¸ë“œì— ì¶”ê°€.', services: ['Terraform', 'Pulumi', 'AWS CDK'] },
      { id: 'docker', name: 'Docker', icon: 'ğŸ³', category: 'devops', cost: 1, hp: 30, attack: 10,
        desc: 'ì»¨í…Œì´ë„ˆì˜ ì‹œì‘. ì–´ë””ì„œë“  ë™ì¼í•˜ê²Œ ì‹¤í–‰. "ë‚´ ì»´ì—ì„œëŠ” ë˜ëŠ”ë°?"ì˜ í•´ê²°ì‚¬.',
        effect: 'ë‚®ì€ ì½”ìŠ¤íŠ¸ë¡œ ë¹ ë¥¸ ë°°ì¹˜. K8sì™€ í•¨ê»˜ ìˆìœ¼ë©´ ê³µê²©ë ¥ +10.', services: ['Docker', 'Podman'] },
      { id: 'prometheus', name: 'Prometheus', icon: 'ğŸ“ˆ', category: 'monitoring', cost: 2, hp: 40, attack: 0,
        desc: 'ë©”íŠ¸ë¦­ ìˆ˜ì§‘ì˜ í‘œì¤€. ì‹œê³„ì—´ ë°ì´í„°ë² ì´ìŠ¤. Grafanaì™€ ì°°ë–¡ê¶í•©.',
        effect: 'ìƒëŒ€ì˜ ë‹¤ìŒ ê³µê²©ì„ ë¯¸ë¦¬ í™•ì¸.', services: ['Prometheus', 'Datadog', 'New Relic'] },
      { id: 'cloudwatch', name: 'CloudWatch', icon: 'ğŸ‘ï¸', category: 'monitoring', cost: 2, hp: 35, attack: 5,
        desc: 'AWS ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤. ë¡œê·¸, ë©”íŠ¸ë¦­, ì•ŒëŒ. ì´ìƒ ê°ì§€ì˜ ëˆˆ.',
        effect: 'ì ì˜ ìŠ¤í…”ìŠ¤ ê³µê²© ë¬´íš¨í™”.', services: ['AWS CloudWatch', 'GCP Cloud Monitoring'] },
      { id: 'ddos', name: 'DDoS', icon: 'ğŸ’¥', category: 'attack', cost: 4, hp: 0, attack: 50,
        desc: 'ë¶„ì‚° ì„œë¹„ìŠ¤ ê±°ë¶€ ê³µê²©. ëŒ€ëŸ‰ì˜ íŠ¸ë˜í”½ìœ¼ë¡œ ì„œë²„ ë§ˆë¹„. ê°€ì¥ í”í•œ ê³µê²©.',
        effect: 'ì¦‰ì‹œ ì‚¬ìš©. ìƒëŒ€ ì„œë²„ì— 50 ë°ë¯¸ì§€.', services: ['ê³µê²© ì¹´ë“œ'] },
      { id: 'sqli', name: 'SQL Injection', icon: 'ğŸ’‰', category: 'attack', cost: 3, hp: 0, attack: 80,
        desc: "ì•…ì˜ì  SQL ì¿¼ë¦¬ ì‚½ì…. DB íƒˆì·¨ì˜ ê³ ì „. Bobby Tablesì˜ ì „ì„¤.",
        effect: 'WAFê°€ ì—†ìœ¼ë©´ 80 ë°ë¯¸ì§€. WAF ìˆìœ¼ë©´ ë¬´íš¨.', services: ['ê³µê²© ì¹´ë“œ'] },
      { id: 'mitm', name: 'MITM', icon: 'ğŸ‘¤', category: 'attack', cost: 2, hp: 0, attack: 40,
        desc: 'Man in the Middle. ì¤‘ê°„ì ê³µê²©. í†µì‹  ë„ì²­ ë° ë³€ì¡°.',
        effect: 'SSLì´ ì—†ìœ¼ë©´ 40 ë°ë¯¸ì§€. SSL ìˆìœ¼ë©´ ë¬´íš¨.', services: ['ê³µê²© ì¹´ë“œ'] },
    ];

    // ê²Œì„ ìƒíƒœ
    let game = {
      started: false,
      turn: 'player',
      mana: 1,
      maxMana: 1,
      turnCount: 1,
      player: { hp: 100, maxHp: 100, field: [], hand: [], deck: [] },
      enemy: { hp: 100, maxHp: 100, field: [], mana: 0 },
      selectedCard: null,
      selectedIndex: null,
      stats: { wins: 0, losses: 0, fastestWin: 999 },
      combo: 0,
      nextEnemyAttack: null
    };

    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ í†µê³„ ë¡œë“œ
    try {
      const saved = localStorage.getItem('serverDefenseStats');
      if (saved) game.stats = JSON.parse(saved);
    } catch(e) {}

    function saveStats() {
      try { localStorage.setItem('serverDefenseStats', JSON.stringify(game.stats)); } catch(e) {}
    }

    // ì  ì¹´ë“œ (ë‚œì´ë„ë³„)
    const enemyCards = {
      easy: [
        { id: 'bot1', name: 'ìŠ¤íŒ¸ë´‡', icon: 'ğŸ¤–', hp: 30, attack: 10 },
        { id: 'bot2', name: 'í¬ë¡¤ëŸ¬', icon: 'ğŸ•·ï¸', hp: 40, attack: 15 }
      ],
      normal: [
        { id: 'bot1', name: 'ìŠ¤íŒ¸ë´‡', icon: 'ğŸ¤–', hp: 30, attack: 10 },
        { id: 'bot2', name: 'í¬ë¡¤ëŸ¬', icon: 'ğŸ•·ï¸', hp: 40, attack: 15 },
        { id: 'bot3', name: 'ë´‡ë„·', icon: 'ğŸ‘¾', hp: 60, attack: 25 }
      ],
      hard: [
        { id: 'bot2', name: 'í¬ë¡¤ëŸ¬', icon: 'ğŸ•·ï¸', hp: 40, attack: 15 },
        { id: 'bot3', name: 'ë´‡ë„·', icon: 'ğŸ‘¾', hp: 60, attack: 25 },
        { id: 'bot4', name: 'APT', icon: 'ğŸ’€', hp: 80, attack: 35 }
      ]
    };

    // ========== ë„ê° ê¸°ëŠ¥ ==========
    function renderCardGrid(filter = 'all') {
      const grid = document.getElementById('cardGrid');
      const cards = filter === 'all' ? allCards : allCards.filter(c => c.category === filter);
      
      grid.innerHTML = cards.map(card => `
        <div class="card-item" onclick="showCardDetail('${card.id}')">
          <div class="icon">${card.icon}</div>
          <div class="name">${card.name}</div>
          <div class="category">${getCategoryName(card.category)}</div>
          <div class="stats">
            <span class="cost">âš¡${card.cost}</span>
            <span class="atk">âš”ï¸${card.attack}</span>
            <span class="hp">â¤ï¸${card.hp}</span>
          </div>
        </div>
      `).join('');
    }

    function getCategoryName(cat) {
      const names = {
        computing: 'ğŸ–¥ï¸ ì»´í“¨íŒ…', storage: 'ğŸ’¾ ìŠ¤í† ë¦¬ì§€', database: 'ğŸ—„ï¸ DB',
        network: 'ğŸŒ ë„¤íŠ¸ì›Œí¬', security: 'ğŸ”’ ë³´ì•ˆ', devops: 'âš™ï¸ DevOps',
        monitoring: 'ğŸ“Š ëª¨ë‹ˆí„°ë§', attack: 'ğŸ’¥ ê³µê²©'
      };
      return names[cat] || cat;
    }

    function showCardDetail(cardId) {
      const card = allCards.find(c => c.id === cardId);
      if (!card) return;

      document.getElementById('modalIcon').textContent = card.icon;
      document.getElementById('modalName').textContent = card.name;
      document.getElementById('modalCategory').textContent = getCategoryName(card.category);
      document.getElementById('modalCost').textContent = card.cost;
      document.getElementById('modalHp').textContent = card.hp;
      document.getElementById('modalAtk').textContent = card.attack;
      document.getElementById('modalDesc').textContent = card.desc;
      document.getElementById('modalEffect').textContent = 'ğŸ’¡ ' + card.effect;
      document.getElementById('modalServices').innerHTML = card.services.map(s => 
        `<span class="service-tag">${s}</span>`
      ).join('');

      document.getElementById('modalOverlay').classList.add('active');
    }

    function closeModal(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('modalOverlay').classList.remove('active');
    }

    // ========== ê²Œì„ ê¸°ëŠ¥ ==========
    function startGame(difficulty) {
      const diffSettings = {
        easy: { enemyHp: 100, playerHp: 100, atkMod: 1.0, spawnRate: 0.25, autoDraw: true, manaRate: 1 },
        normal: { enemyHp: 120, playerHp: 80, atkMod: 1.2, spawnRate: 0.4, autoDraw: false, manaRate: 1 },
        hard: { enemyHp: 150, playerHp: 70, atkMod: 1.5, spawnRate: 0.5, autoDraw: false, manaRate: 0.5 }
      };
      const settings = diffSettings[difficulty];

      game = {
        ...game,
        started: true,
        turn: 'player',
        mana: 1,
        maxMana: 1,
        turnCount: 1,
        difficulty,
        settings,
        combo: 0,
        nextEnemyAttack: null,
        player: { hp: settings.playerHp, maxHp: settings.playerHp, field: [], hand: [], deck: [] },
        enemy: { 
          hp: settings.enemyHp,
          maxHp: settings.enemyHp,
          field: [],
          mana: 0
        },
        selectedCard: null,
        selectedIndex: null
      };

      // ë± ìƒì„± (ê³µê²© ì¹´ë“œ ì œì™¸)
      const deckCards = allCards.filter(c => c.category !== 'attack');
      game.player.deck = shuffle([...deckCards, ...deckCards]).slice(0, 20);

      // ì´ˆê¸° í•¸ë“œ
      for (let i = 0; i < 4; i++) drawCard();

      // Prometheus íš¨ê³¼: ë‹¤ìŒ ê³µê²© ë¯¸ë¦¬ë³´ê¸°
      prepareNextEnemyAttack();

      document.body.classList.add('game-mode');
      document.getElementById('gameStart').style.display = 'none';
      document.getElementById('battleLog').style.display = 'block';
      updateBattleUI();
      addLog(`ğŸ® ${difficulty.toUpperCase()} ëª¨ë“œ ì‹œì‘!`, 'info');
    }

    function exitGame() {
      document.body.classList.remove('game-mode');
      document.getElementById('gameStart').style.display = 'block';
      document.getElementById('battleLog').style.display = 'none';
      game.started = false;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function drawCard() {
      if (game.player.deck.length > 0 && game.player.hand.length < 7) {
        game.player.hand.push({ ...game.player.deck.pop(), uid: Date.now() + Math.random() });
      }
    }

    function selectHandCard(index) {
      const card = game.player.hand[index];
      if (!card) return;

      game.selectedCard = card;
      game.selectedIndex = index;

      document.getElementById('gameCardIcon').textContent = card.icon;
      document.getElementById('gameCardName').textContent = card.name;
      document.getElementById('gameCardCategory').textContent = getCategoryName(card.category);
      document.getElementById('gameCardCost').textContent = card.cost;
      document.getElementById('gameCardHp').textContent = card.hp;
      document.getElementById('gameCardAtk').textContent = card.attack;
      document.getElementById('gameCardDesc').textContent = card.desc;
      document.getElementById('gameCardEffect').textContent = 'ğŸ’¡ ' + card.effect;

      const canPlay = card.cost <= game.mana;
      document.getElementById('gameCardActions').innerHTML = canPlay
        ? `<button class="btn btn-primary" onclick="playSelectedCard()">ë°°ì¹˜</button>
           <button class="btn btn-danger" onclick="closeGameCardModal()">ì·¨ì†Œ</button>`
        : `<button class="btn btn-danger" onclick="closeGameCardModal()">ë§ˆë‚˜ ë¶€ì¡± (${card.cost}í•„ìš”)</button>`;

      document.getElementById('gameCardModal').classList.add('active');
    }

    function closeGameCardModal(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('gameCardModal').classList.remove('active');
      game.selectedCard = null;
      game.selectedIndex = null;
    }

    function playSelectedCard() {
      if (game.selectedIndex === null) return;
      const card = game.player.hand[game.selectedIndex];
      if (card.cost > game.mana) return;

      game.mana -= card.cost;
      const newCard = { ...card, currentHp: card.hp, canAttack: false, bonusAtk: 0 };
      
      // Fargate íŠ¹ìˆ˜ íš¨ê³¼: ë°°ì¹˜ ì¦‰ì‹œ ê³µê²© ê°€ëŠ¥
      if (card.id === 'fargate') {
        newCard.canAttack = true;
        addLog(`ğŸš€ Fargate ì¦‰ì‹œ ë°°ì¹˜ ì™„ë£Œ!`, 'info');
      }

      game.player.field.push(newCard);
      game.player.hand.splice(game.selectedIndex, 1);
      
      // ì‹œë„ˆì§€ íš¨ê³¼ ì ìš©
      applySynergyEffects();
      
      addLog(`${card.icon} ${card.name} ë°°ì¹˜!`, 'info');
      closeGameCardModal();
      updateBattleUI();
    }

    // ì‹œë„ˆì§€ íš¨ê³¼ ê³„ì‚°
    function applySynergyEffects() {
      const field = game.player.field;
      const hasCard = (id) => field.some(c => c.id === id);
      
      field.forEach(card => {
        card.bonusAtk = 0;
        
        // Route 53: ëª¨ë“  ì¹´ë“œ ê³µê²©ë ¥ +5
        if (hasCard('route53') && card.id !== 'route53') {
          card.bonusAtk += 5;
        }
        
        // Lambda + DynamoDB: Lambda ê³µê²©ë ¥ +15
        if (card.id === 'lambda' && hasCard('dynamodb')) {
          card.bonusAtk += 15;
        }
        
        // Docker + K8s: Docker ê³µê²©ë ¥ +10
        if (card.id === 'docker' && hasCard('k8s')) {
          card.bonusAtk += 10;
        }
        
        // EBS + EC2: EC2 HP +30 (í•œ ë²ˆë§Œ)
        if (card.id === 'ec2' && hasCard('ebs') && !card.ebsBoosted) {
          card.currentHp = Math.min(card.hp + 30, card.currentHp + 30);
          card.ebsBoosted = true;
          addLog(`ğŸ’¾ EBS ì—°ê²°! EC2 HP +30`, 'info');
        }
      });
    }

    // ë°ë¯¸ì§€ ê°ì†Œ ê³„ì‚°
    function calculateDamageReduction(baseDmg, target) {
      let dmg = baseDmg;
      const field = game.player.field;
      
      // SSL/TLS: -5
      if (field.some(c => c.id === 'ssl')) dmg -= 5;
      
      // VPC: -5
      if (field.some(c => c.id === 'vpc')) dmg -= 5;
      
      // Redis + DB: DB ì•ì— Redis ìˆìœ¼ë©´ -30%
      if (target && ['rds', 'dynamodb'].includes(target.id)) {
        const redisIdx = field.findIndex(c => c.id === 'redis');
        const targetIdx = field.findIndex(c => c.uid === target.uid);
        if (redisIdx !== -1 && redisIdx < targetIdx) {
          dmg = Math.floor(dmg * 0.7);
          addLog(`ğŸ”´ Redis ìºì‹œ ë³´í˜¸! ë°ë¯¸ì§€ -30%`, 'info');
        }
      }
      
      // ELB: ì„œë²„ 2ê°œ ì´ìƒì´ë©´ ë°ë¯¸ì§€ ë¶„ì‚° (50%)
      if (field.some(c => c.id === 'elb') && field.filter(c => c.category === 'computing').length >= 2) {
        dmg = Math.floor(dmg * 0.5);
        addLog(`âš–ï¸ ELB ë¶€í•˜ ë¶„ì‚°! ë°ë¯¸ì§€ -50%`, 'info');
      }
      
      return Math.max(0, dmg);
    }

    function attackWith(index) {
      const card = game.player.field[index];
      if (!card || !card.canAttack || game.turn !== 'player') return;

      card.canAttack = false;
      game.combo++;
      
      // ì´ ê³µê²©ë ¥ (ê¸°ë³¸ + ë³´ë„ˆìŠ¤ + ì½¤ë³´)
      const totalAtk = card.attack + (card.bonusAtk || 0) + (game.combo > 1 ? game.combo * 2 : 0);
      
      // ê³µê²© ì• ë‹ˆë©”ì´ì…˜
      showAttackAnimation(index, 'player');

      if (game.enemy.field.length > 0) {
        const target = game.enemy.field[0];
        target.currentHp -= totalAtk;
        
        const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
        addLog(`${card.icon} â†’ ${target.icon} (${totalAtk})${comboText}`, 'damage');
        showDamageNumber(totalAtk, 'enemy');
        
        if (target.currentHp <= 0) {
          game.enemy.field.shift();
          addLog(`${target.icon} íŒŒê´´!`, 'damage');
        }
      } else {
        game.enemy.hp = Math.max(0, game.enemy.hp - totalAtk);
        const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
        addLog(`${card.icon} ì§ì ‘ ê³µê²©! (${totalAtk})${comboText}`, 'damage');
        showDamageNumber(totalAtk, 'enemy-hp');
      }

      checkGameOver();
      updateBattleUI();
    }

    // ê³µê²© ì• ë‹ˆë©”ì´ì…˜
    function showAttackAnimation(index, side) {
      const field = document.getElementById(side === 'player' ? 'playerField' : 'enemyField');
      const cards = field.querySelectorAll('.field-card');
      if (cards[index]) {
        cards[index].classList.add('attacking');
        setTimeout(() => cards[index].classList.remove('attacking'), 300);
      }
    }

    // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ
    function showDamageNumber(dmg, target) {
      const el = document.createElement('div');
      el.className = 'damage-number';
      el.textContent = `-${dmg}`;
      el.style.cssText = `
        position: fixed;
        top: ${target === 'enemy-hp' ? '15%' : '40%'};
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.5em;
        font-weight: bold;
        color: #e74c3c;
        text-shadow: 0 0 10px #e74c3c;
        animation: floatUp 1s forwards;
        z-index: 1000;
        pointer-events: none;
      `;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }

    function endTurn() {
      if (game.turn !== 'player') return;
      game.turn = 'enemy';
      document.getElementById('endTurnBtn').disabled = true;
      updateBattleUI();
      setTimeout(enemyTurn, 1000);
    }

    // ì  ê³µê²© ëª©ë¡ ì¤€ë¹„
    function prepareNextEnemyAttack() {
      const attacks = [
        { name: 'DDoS', icon: 'ğŸ’¥', dmg: 50, type: 'normal' },
        { name: 'íŠ¸ë˜í”½ ìŠ¤íŒŒì´í¬', icon: 'ğŸ“ˆ', dmg: 30, type: 'spike', blockedBy: 'cdn' },
        { name: 'SQL Injection', icon: 'ğŸ’‰', dmg: 80, type: 'sql', blockedBy: 'waf' },
        { name: 'MITM ê³µê²©', icon: 'ğŸ‘¤', dmg: 40, type: 'mitm', blockedBy: 'ssl' },
        { name: 'ê¶Œí•œ ìƒìŠ¹', icon: 'ğŸ‘‘', dmg: 60, type: 'priv', blockedBy: 'iam' },
        { name: 'ë°ì´í„° ìœ ì¶œ', icon: 'ğŸ“¤', dmg: 45, type: 'leak', blockedBy: 'kms' },
        { name: 'ìŠ¤í…”ìŠ¤ ê³µê²©', icon: 'ğŸ‘»', dmg: 35, type: 'stealth', blockedBy: 'cloudwatch' }
      ];
      
      // ë‚œì´ë„ë³„ ê³µê²©ë ¥ ì¡°ì •
      const mod = game.settings?.atkMod || 1;
      game.nextEnemyAttack = attacks[Math.floor(Math.random() * attacks.length)];
      game.nextEnemyAttack.dmg = Math.floor(game.nextEnemyAttack.dmg * mod);
    }

    function enemyTurn() {
      game.enemy.mana++;
      const settings = game.settings || { spawnRate: 0.2, atkMod: 1 };
      
      // 1. ì  ìœ ë‹› ë°°ì¹˜ (ë‚œì´ë„ë³„ í™•ë¥ )
      if (Math.random() < settings.spawnRate && game.enemy.mana >= 2) {
        const cards = enemyCards[game.difficulty] || enemyCards.normal;
        const card = cards[Math.floor(Math.random() * cards.length)];
        game.enemy.field.push({ ...card, currentHp: card.hp });
        game.enemy.mana -= 2;
        addLog(`ğŸš¨ ì  ${card.icon} ${card.name} ë“±ì¥!`, 'damage');
        updateBattleUI();
      }

      // 2. ì  ìœ ë‹› ê³µê²©
      setTimeout(() => {
        game.enemy.field.forEach(enemyCard => {
          if (game.player.field.length > 0) {
            const target = game.player.field[0];
            const dmg = calculateDamageReduction(enemyCard.attack, target);
            target.currentHp -= dmg;
            addLog(`${enemyCard.icon} â†’ ${target.icon} (${dmg})`, 'damage');
            showDamageNumber(dmg, 'player');
            
            if (target.currentHp <= 0) {
              handleCardDestruction(target, game.player.field);
            }
          } else {
            game.player.hp = Math.max(0, game.player.hp - enemyCard.attack);
            addLog(`${enemyCard.icon} ì§ì ‘ ê³µê²©! (${enemyCard.attack})`, 'damage');
          }
        });
        
        updateBattleUI();
        checkGameOver();

        // 3. íŠ¹ìˆ˜ ê³µê²© (prepared attack)
        setTimeout(() => {
          if (game.nextEnemyAttack) {
            executeEnemyAttack(game.nextEnemyAttack);
          }
          prepareNextEnemyAttack();
          
          // Prometheus íš¨ê³¼: ë‹¤ìŒ ê³µê²© ë¯¸ë¦¬ë³´ê¸°
          if (game.player.field.some(c => c.id === 'prometheus')) {
            addLog(`ğŸ“ˆ ë‹¤ìŒ ê³µê²© ì˜ˆê³ : ${game.nextEnemyAttack.icon} ${game.nextEnemyAttack.name}`, 'info');
          }
          
          checkGameOver();
          setTimeout(startPlayerTurn, 500);
        }, 600);
      }, 400);
    }

    function executeEnemyAttack(atk) {
      let dmg = atk.dmg;
      let blocked = false;

      // íŠ¹ìˆ˜ ë°©ì–´ ì²´í¬
      if (atk.blockedBy && game.player.field.some(c => c.id === atk.blockedBy)) {
        const blocker = game.player.field.find(c => c.id === atk.blockedBy);
        addLog(`${blocker.icon} ${blocker.name}ì´(ê°€) ${atk.name} ì°¨ë‹¨!`, 'info');
        blocked = true;
      }

      if (!blocked) {
        // ë°ë¯¸ì§€ ê°ì†Œ ì ìš©
        const target = game.player.field[0] || null;
        dmg = calculateDamageReduction(dmg, target);

        if (game.player.field.length > 0) {
          target.currentHp -= dmg;
          addLog(`${atk.icon} ${atk.name} â†’ ${target.icon} (${dmg})`, 'damage');
          showDamageNumber(dmg, 'player');
          
          if (target.currentHp <= 0) {
            handleCardDestruction(target, game.player.field);
          }
        } else {
          game.player.hp = Math.max(0, game.player.hp - dmg);
          addLog(`${atk.icon} ${atk.name}! (${dmg})`, 'damage');
          showDamageNumber(dmg, 'player-hp');
        }
      }
      
      updateBattleUI();
    }

    // ì¹´ë“œ íŒŒê´´ ì²˜ë¦¬ (íŠ¹ìˆ˜ íš¨ê³¼)
    function handleCardDestruction(card, field) {
      const idx = field.findIndex(c => c.uid === card.uid);
      if (idx === -1) return;

      // K8s: 50% í™•ë¥  ë¶€í™œ
      if (card.id === 'k8s' && Math.random() < 0.5) {
        card.currentHp = Math.floor(card.hp * 0.3);
        addLog(`â˜¸ï¸ K8s Pod ë¶€í™œ! (HP ${card.currentHp})`, 'info');
        return;
      }

      // Terraform: í•¸ë“œì— ë³µì‚¬ë³¸ ì¶”ê°€
      if (card.id === 'terraform' && game.player.hand.length < 7) {
        const copy = allCards.find(c => c.id === 'terraform');
        game.player.hand.push({ ...copy, uid: Date.now() + Math.random() });
        addLog(`ğŸ—ï¸ Terraform IaC ì¬ìƒì„±!`, 'info');
      }

      // S3: ëª¨ë“  ì•„êµ° HP +20
      if (card.id === 's3') {
        field.forEach(c => {
          if (c.uid !== card.uid) {
            c.currentHp = Math.min(c.hp, c.currentHp + 20);
          }
        });
        addLog(`ğŸª£ S3 ë°±ì—… ë³µì›! ëª¨ë“  ì•„êµ° HP +20`, 'info');
      }

      field.splice(idx, 1);
      addLog(`${card.icon} íŒŒê´´!`, 'damage');
    }

    function startPlayerTurn() {
      game.turn = 'player';
      game.turnCount++;
      
      // ë§ˆë‚˜ ì¦ê°€ (ë‚œì´ë„ë³„)
      const manaIncrease = game.settings.manaRate === 1 ? 1 : (game.turnCount % 2 === 0 ? 1 : 0);
      game.maxMana = Math.min(10, game.maxMana + manaIncrease);
      game.mana = game.maxMana;
      game.combo = 0; // ì½¤ë³´ ë¦¬ì…‹

      // ìë™ ë“œë¡œìš° (ë‚œì´ë„ë³„)
      if (game.settings.autoDraw) {
        drawCard();
      } else {
        addLog(`âš ï¸ ìë™ ë“œë¡œìš° ì—†ìŒ! CI/CD í•„ìš”`, 'info');
      }

      // RDS íšŒë³µ
      game.player.field.forEach(c => {
        if (c.id === 'rds') {
          c.currentHp = Math.min(c.hp, c.currentHp + 5);
          addLog(`ğŸ—„ï¸ RDS ìë™ íšŒë³µ +5`, 'info');
        }
      });

      // CI/CD ì¶”ê°€ ë“œë¡œìš°
      if (game.player.field.some(c => c.id === 'cicd')) {
        drawCard();
        addLog('ğŸ”„ CI/CD ì¶”ê°€ ë“œë¡œìš°!', 'info');
      }

      // ì‹œë„ˆì§€ ì¬ê³„ì‚°
      applySynergyEffects();

      game.player.field.forEach(c => c.canAttack = true);
      document.getElementById('endTurnBtn').disabled = false;
      
      // 5í„´ë§ˆë‹¤ ì´ë²¤íŠ¸
      if (game.turnCount % 5 === 0) {
        triggerRandomEvent();
      }
      
      addLog(`--- í„´ ${game.turnCount} ---`, 'info');
      updateBattleUI();
    }

    // ëœë¤ ì´ë²¤íŠ¸
    function triggerRandomEvent() {
      const events = [
        { name: 'íŠ¸ë˜í”½ ê¸‰ì¦', effect: () => { game.enemy.hp = Math.max(0, game.enemy.hp - 15); addLog('ğŸ“Š íŠ¸ë˜í”½ ê¸‰ì¦! ì  ì„œë²„ ê³¼ë¶€í•˜ (-15 HP)', 'info'); }},
        { name: 'í´ë¼ìš°ë“œ í¬ë ˆë”§', effect: () => { game.mana += 2; addLog('ğŸ’° í´ë¼ìš°ë“œ í¬ë ˆë”§ ì§€ê¸‰! ë§ˆë‚˜ +2', 'info'); }},
        { name: 'ë³´ì•ˆ íŒ¨ì¹˜', effect: () => { game.player.field.forEach(c => c.currentHp = Math.min(c.hp, c.currentHp + 10)); addLog('ğŸ”’ ë³´ì•ˆ íŒ¨ì¹˜ ì ìš©! ëª¨ë“  ìœ ë‹› HP +10', 'info'); }},
        { name: 'ì˜¤í† ìŠ¤ì¼€ì¼ë§', effect: () => { drawCard(); drawCard(); addLog('ğŸ“ˆ ì˜¤í† ìŠ¤ì¼€ì¼ë§! ì¹´ë“œ 2ì¥ ë“œë¡œìš°', 'info'); }}
      ];
      const event = events[Math.floor(Math.random() * events.length)];
      addLog(`âš¡ ì´ë²¤íŠ¸: ${event.name}`, 'info');
      event.effect();
    }

    function checkGameOver() {
      if (game.enemy.hp <= 0) {
        setTimeout(() => showGameOver(true), 300);
      } else if (game.player.hp <= 0) {
        setTimeout(() => showGameOver(false), 300);
      }
    }

    function showGameOver(win) {
      // í†µê³„ ì—…ë°ì´íŠ¸
      if (win) {
        game.stats.wins++;
        if (game.turnCount < game.stats.fastestWin) {
          game.stats.fastestWin = game.turnCount;
        }
      } else {
        game.stats.losses++;
      }
      saveStats();

      const el = document.getElementById('gameOver');
      el.className = 'game-over active ' + (win ? 'win' : 'lose');
      
      const statsText = `ì „ì : ${game.stats.wins}ìŠ¹ ${game.stats.losses}íŒ¨ | ìµœë‹¨ í´ë¦¬ì–´: ${game.stats.fastestWin === 999 ? '-' : game.stats.fastestWin + 'í„´'}`;
      
      document.getElementById('gameOverTitle').textContent = win ? 'ğŸ‰ ìŠ¹ë¦¬!' : 'ğŸ’€ íŒ¨ë°°';
      document.getElementById('gameOverMsg').innerHTML = `
        ${win ? 'ì„œë²„ë¥¼ ë‹¤ìš´ì‹œì¼°ìŠµë‹ˆë‹¤!' : 'ì„œë²„ê°€ ë‹¤ìš´ë˜ì—ˆìŠµë‹ˆë‹¤...'}<br>
        <small style="color: #888;">${game.turnCount}í„´ ì†Œìš” | ${statsText}</small>
      `;
    }

    function restartGame() {
      document.getElementById('gameOver').className = 'game-over';
      exitGame();
    }

    function addLog(msg, type = '') {
      const log = document.getElementById('battleLog');
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = msg;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
      while (log.children.length > 10) log.removeChild(log.firstChild);
    }

    function updateBattleUI() {
      // HP
      const pPct = (game.player.hp / game.player.maxHp) * 100;
      const ePct = (game.enemy.hp / game.enemy.maxHp) * 100;
      
      document.getElementById('playerHpFill').style.width = pPct + '%';
      document.getElementById('playerHpFill').className = 'hp-fill' + (pPct < 30 ? ' low' : '');
      document.getElementById('playerHpText').textContent = `${game.player.hp}/${game.player.maxHp}`;
      
      document.getElementById('enemyHpFill').style.width = ePct + '%';
      document.getElementById('enemyHpFill').className = 'hp-fill' + (ePct < 30 ? ' low' : '');
      document.getElementById('enemyHpText').textContent = `${game.enemy.hp}/${game.enemy.maxHp}`;

      document.getElementById('manaText').textContent = `${game.mana}/${game.maxMana}`;

      // í•¸ë“œ
      const hand = document.getElementById('playerHand');
      hand.innerHTML = game.player.hand.map((card, i) => {
        const canPlay = card.cost <= game.mana;
        const rot = (i - (game.player.hand.length - 1) / 2) * 5;
        return `
          <div class="hand-card ${!canPlay ? 'disabled' : 'playable'}" 
               style="transform: rotate(${rot}deg);"
               data-index="${i}">
            <span class="cost">${card.cost}</span>
            <span class="icon">${card.icon}</span>
            <span class="name">${card.name}</span>
            <span class="card-stats">
              <span style="color:#e74c3c">âš”${card.attack}</span>
              <span style="color:#2ecc71">â¤${card.hp}</span>
            </span>
          </div>
        `;
      }).join('');

      // í”Œë ˆì´ì–´ í•„ë“œ
      const pField = document.getElementById('playerField');
      pField.innerHTML = game.player.field.length > 0
        ? game.player.field.map((card, i) => {
            const totalAtk = card.attack + (card.bonusAtk || 0);
            const hasBonus = card.bonusAtk > 0;
            return `
            <div class="field-card ${card.canAttack ? 'can-attack' : ''} ${hasBonus ? 'synergy' : ''}" 
                 data-field-index="${i}" data-card-id="${card.id}">
              <span class="icon">${card.icon}</span>
              <span class="name">${card.name}</span>
              <span class="card-atk" ${hasBonus ? 'style="background:linear-gradient(135deg,#f39c12,#d68910)"' : ''}>${totalAtk}</span>
              <span class="card-hp">${card.currentHp}</span>
            </div>
          `}).join('')
        : '<span class="field-placeholder">ì¹´ë“œë¥¼ ë°°ì¹˜í•˜ì„¸ìš”</span>';

      // ì  í•„ë“œ
      const eField = document.getElementById('enemyField');
      eField.innerHTML = game.enemy.field.length > 0
        ? game.enemy.field.map((card, i) => `
            <div class="field-card" data-enemy-index="${i}" data-card-id="${card.id}">
              <span class="icon">${card.icon}</span>
              <span class="name">${card.name}</span>
              <span class="card-atk">${card.attack}</span>
              <span class="card-hp">${card.currentHp}</span>
            </div>
          `).join('')
        : '<span class="field-placeholder">ì  ì„œë²„</span>';

      bindHandCardEvents();
      bindFieldCardEvents();
    }

    // í•„ë“œ ì¹´ë“œ ì´ë²¤íŠ¸ (íƒ­=ì„¤ëª…, ë“œë˜ê·¸=ê³µê²©)
    let attackDragState = { active: false, cardIndex: null, startX: 0, startY: 0 };

    function bindFieldCardEvents() {
      // í”Œë ˆì´ì–´ í•„ë“œ ì¹´ë“œ
      document.querySelectorAll('#playerField .field-card[data-field-index]').forEach(el => {
        const fieldIndex = parseInt(el.dataset.fieldIndex);
        let startTime = 0;
        let moved = false;

        el.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const card = game.player.field[fieldIndex];
          if (!card || !card.canAttack || game.turn !== 'player') return;
          
          startTime = Date.now();
          moved = false;
          const touch = e.touches[0];
          attackDragState = { active: false, cardIndex: fieldIndex, startX: touch.clientX, startY: touch.clientY };
        });

        el.addEventListener('touchmove', (e) => {
          if (attackDragState.cardIndex !== fieldIndex) return;
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - attackDragState.startX);
          const dy = Math.abs(touch.clientY - attackDragState.startY);
          
          if (dx > 10 || dy > 10) {
            moved = true;
            attackDragState.active = true;
            showAttackTargets();
            updateAttackArrow(touch.clientX, touch.clientY);
          }
        });

        el.addEventListener('touchend', (e) => {
          if (attackDragState.cardIndex !== fieldIndex) return;
          
          if (!moved && Date.now() - startTime < 300) {
            // íƒ­ = ì„¤ëª… í‘œì‹œ
            const card = game.player.field[fieldIndex];
            if (card) showFieldCardInfo(card);
          } else if (attackDragState.active) {
            // ë“œë˜ê·¸ = ê³µê²©
            const touch = e.changedTouches[0];
            executeAttackOnTarget(fieldIndex, touch.clientX, touch.clientY);
          }
          
          hideAttackTargets();
          attackDragState = { active: false, cardIndex: null, startX: 0, startY: 0 };
        });

        // PC: í´ë¦­=ì„¤ëª…
        el.addEventListener('click', (e) => {
          if (e.detail === 1) {
            setTimeout(() => {
              if (!attackDragState.active) {
                const card = game.player.field[fieldIndex];
                if (card) showFieldCardInfo(card);
              }
            }, 200);
          }
        });
      });

      // ì  í•„ë“œ ì¹´ë“œ (íƒ­=ì„¤ëª…)
      document.querySelectorAll('#enemyField .field-card[data-enemy-index]').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.enemyIndex);
          const card = game.enemy.field[idx];
          if (card) showFieldCardInfo(card);
        });
        el.addEventListener('touchend', (e) => {
          e.preventDefault();
          const idx = parseInt(el.dataset.enemyIndex);
          const card = game.enemy.field[idx];
          if (card) showFieldCardInfo(card);
        });
      });
    }

    // ê³µê²© ëŒ€ìƒ í•˜ì´ë¼ì´íŠ¸
    function showAttackTargets() {
      document.querySelectorAll('#enemyField .field-card').forEach(el => {
        el.classList.add('attack-target');
      });
      document.getElementById('enemyHpBar')?.classList.add('attack-target');
    }

    function hideAttackTargets() {
      document.querySelectorAll('.attack-target').forEach(el => {
        el.classList.remove('attack-target');
      });
      const arrow = document.getElementById('attackArrow');
      if (arrow) arrow.style.display = 'none';
    }

    function updateAttackArrow(x, y) {
      let arrow = document.getElementById('attackArrow');
      if (!arrow) {
        arrow = document.createElement('div');
        arrow.id = 'attackArrow';
        arrow.style.cssText = `
          position: fixed; pointer-events: none; z-index: 1000;
          width: 20px; height: 20px; border-radius: 50%;
          background: radial-gradient(circle, #e74c3c, transparent);
          box-shadow: 0 0 20px #e74c3c;
          transform: translate(-50%, -50%);
        `;
        document.body.appendChild(arrow);
      }
      arrow.style.display = 'block';
      arrow.style.left = x + 'px';
      arrow.style.top = y + 'px';
    }

    function executeAttackOnTarget(attackerIndex, x, y) {
      const card = game.player.field[attackerIndex];
      if (!card || !card.canAttack || game.turn !== 'player') return;

      // ì  ìœ ë‹› íƒ€ê²Ÿ ì²´í¬
      const enemyCards = document.querySelectorAll('#enemyField .field-card');
      for (let i = 0; i < enemyCards.length; i++) {
        const rect = enemyCards[i].getBoundingClientRect();
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          attackEnemyCard(attackerIndex, i);
          return;
        }
      }

      // ì  HP ì§ì ‘ ê³µê²© ì²´í¬
      const hpBar = document.getElementById('enemyHpBar');
      if (hpBar) {
        const rect = hpBar.getBoundingClientRect();
        if (x >= rect.left - 50 && x <= rect.right + 50 && y >= rect.top - 30 && y <= rect.bottom + 30) {
          if (game.enemy.field.length === 0) {
            attackDirectly(attackerIndex);
          } else {
            addLog('âš ï¸ ì  ìœ ë‹›ì´ ìˆì–´ ì§ì ‘ ê³µê²© ë¶ˆê°€!', 'info');
          }
          return;
        }
      }
    }

    function attackEnemyCard(attackerIndex, targetIndex) {
      const attacker = game.player.field[attackerIndex];
      const target = game.enemy.field[targetIndex];
      if (!attacker || !target || !attacker.canAttack) return;

      attacker.canAttack = false;
      game.combo++;
      
      const totalAtk = attacker.attack + (attacker.bonusAtk || 0) + (game.combo > 1 ? game.combo * 2 : 0);
      target.currentHp -= totalAtk;
      
      showAttackAnimation(attackerIndex, 'player');
      const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
      addLog(`${attacker.icon} â†’ ${target.icon} (${totalAtk})${comboText}`, 'damage');
      showDamageNumber(totalAtk, 'enemy');
      
      if (target.currentHp <= 0) {
        game.enemy.field.splice(targetIndex, 1);
        addLog(`${target.icon} íŒŒê´´!`, 'damage');
      }
      
      checkGameOver();
      updateBattleUI();
    }

    function attackDirectly(attackerIndex) {
      const attacker = game.player.field[attackerIndex];
      if (!attacker || !attacker.canAttack) return;

      attacker.canAttack = false;
      game.combo++;
      
      const totalAtk = attacker.attack + (attacker.bonusAtk || 0) + (game.combo > 1 ? game.combo * 2 : 0);
      game.enemy.hp = Math.max(0, game.enemy.hp - totalAtk);
      
      showAttackAnimation(attackerIndex, 'player');
      const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
      addLog(`${attacker.icon} ì§ì ‘ ê³µê²©! (${totalAtk})${comboText}`, 'damage');
      showDamageNumber(totalAtk, 'enemy-hp');
      
      checkGameOver();
      updateBattleUI();
    }

    // í•„ë“œ ì¹´ë“œ ì •ë³´ í‘œì‹œ
    function showFieldCardInfo(card) {
      document.getElementById('gameCardIcon').textContent = card.icon;
      document.getElementById('gameCardName').textContent = card.name;
      document.getElementById('gameCardCategory').textContent = getCategoryName(card.category || 'attack');
      document.getElementById('gameCardCost').textContent = card.cost || '-';
      document.getElementById('gameCardHp').textContent = card.currentHp || card.hp;
      document.getElementById('gameCardAtk').textContent = (card.attack || 0) + (card.bonusAtk || 0);
      document.getElementById('gameCardDesc').textContent = card.desc || 'ì  ìœ ë‹›';
      document.getElementById('gameCardEffect').textContent = 'ğŸ’¡ ' + (card.effect || 'ê³µê²© ìœ ë‹›');
      document.getElementById('gameCardActions').innerHTML = `
        <button class="btn btn-danger" onclick="closeGameCardModal()">ë‹«ê¸°</button>
      `;
      document.getElementById('gameCardModal').classList.add('active');
    }

    // ========== ë“œë˜ê·¸ ì‹œìŠ¤í…œ (í•¸ë“œ ì¹´ë“œ) ==========
    let dragState = { active: false, cardIndex: null, startX: 0, startY: 0, startTime: 0 };

    function bindHandCardEvents() {
      const cards = document.querySelectorAll('#playerHand .hand-card');
      cards.forEach((card, index) => {
        card.addEventListener('touchstart', (e) => startHandDrag(e, index), { passive: false });
        card.addEventListener('mousedown', (e) => startHandDrag(e, index));
      });
    }

    function startHandDrag(e, index) {
      const card = game.player.hand[index];
      if (!card) return;

      e.preventDefault();
      const touch = e.touches ? e.touches[0] : e;
      
      dragState.startX = touch.clientX;
      dragState.startY = touch.clientY;
      dragState.cardIndex = index;
      dragState.startTime = Date.now();
      dragState.active = false;

      document.addEventListener('touchmove', onHandDragMove, { passive: false });
      document.addEventListener('touchend', onHandDragEnd);
      document.addEventListener('mousemove', onHandDragMove);
      document.addEventListener('mouseup', onHandDragEnd);
    }

    function onHandDragMove(e) {
      e.preventDefault();
      const touch = e.touches ? e.touches[0] : e;
      const dx = touch.clientX - dragState.startX;
      const dy = touch.clientY - dragState.startY;

      // ë“œë˜ê·¸ ì‹œì‘ (ì›€ì§ì„ ê°ì§€)
      if (!dragState.active && (Math.abs(dx) > 15 || Math.abs(dy) > 15)) {
        const card = game.player.hand[dragState.cardIndex];
        if (card && card.cost <= game.mana) {
          dragState.active = true;
          showDragGhost(dragState.cardIndex, touch.clientX, touch.clientY);
          const cards = document.querySelectorAll('#playerHand .hand-card');
          if (cards[dragState.cardIndex]) cards[dragState.cardIndex].classList.add('dragging');
        }
      }

      if (dragState.active) {
        moveDragGhost(touch.clientX, touch.clientY);
        checkDropTarget(touch.clientX, touch.clientY);
      }
    }

    function onHandDragEnd(e) {
      document.removeEventListener('touchmove', onHandDragMove);
      document.removeEventListener('touchend', onHandDragEnd);
      document.removeEventListener('mousemove', onHandDragMove);
      document.removeEventListener('mouseup', onHandDragEnd);

      const elapsed = Date.now() - dragState.startTime;

      if (dragState.active) {
        // ë“œë˜ê·¸ â†’ ë°°ì¹˜ ì‹œë„
        const touch = e.changedTouches ? e.changedTouches[0] : e;
        tryDrop(touch.clientX, touch.clientY);
        hideDragGhost();
        document.querySelectorAll('#playerHand .hand-card').forEach(c => c.classList.remove('dragging'));
        document.getElementById('playerField').classList.remove('drop-target');
      } else if (elapsed < 300) {
        // ì§§ì€ íƒ­ â†’ ì„¤ëª… í‘œì‹œ
        const card = game.player.hand[dragState.cardIndex];
        if (card) showHandCardInfo(card, dragState.cardIndex);
      }

      dragState.active = false;
      dragState.cardIndex = null;
    }

    // í•¸ë“œ ì¹´ë“œ ì •ë³´ í‘œì‹œ (ë°°ì¹˜ ë²„íŠ¼ í¬í•¨)
    function showHandCardInfo(card, handIndex) {
      document.getElementById('gameCardIcon').textContent = card.icon;
      document.getElementById('gameCardName').textContent = card.name;
      document.getElementById('gameCardCategory').textContent = getCategoryName(card.category);
      document.getElementById('gameCardCost').textContent = card.cost;
      document.getElementById('gameCardHp').textContent = card.hp;
      document.getElementById('gameCardAtk').textContent = card.attack;
      document.getElementById('gameCardDesc').textContent = card.desc;
      document.getElementById('gameCardEffect').textContent = 'ğŸ’¡ ' + card.effect;
      
      const canPlay = card.cost <= game.mana;
      document.getElementById('gameCardActions').innerHTML = `
        <button class="btn btn-primary" ${canPlay ? '' : 'disabled'} onclick="playCardFromModal(${handIndex})">
          ${canPlay ? 'âš¡ ë°°ì¹˜' : 'ë§ˆë‚˜ ë¶€ì¡±'}
        </button>
        <button class="btn btn-danger" onclick="closeGameCardModal()">ë‹«ê¸°</button>
      `;
      document.getElementById('gameCardModal').classList.add('active');
      game.selectedIndex = handIndex;
    }

    function playCardFromModal(index) {
      game.selectedIndex = index;
      playSelectedCard();
    }

    function showDragGhost(index, x, y) {
      const card = game.player.hand[index];
      const ghost = document.getElementById('dragGhost');
      ghost.innerHTML = `
        <div class="hand-card">
          <span class="cost">${card.cost}</span>
          <span class="icon">${card.icon}</span>
          <span class="name">${card.name}</span>
        </div>
      `;
      ghost.style.left = x + 'px';
      ghost.style.top = y + 'px';
      ghost.style.display = 'block';
    }

    function moveDragGhost(x, y) {
      const ghost = document.getElementById('dragGhost');
      ghost.style.left = x + 'px';
      ghost.style.top = y + 'px';
    }

    function hideDragGhost() {
      document.getElementById('dragGhost').style.display = 'none';
    }

    function checkDropTarget(x, y) {
      const field = document.getElementById('playerField');
      const rect = field.getBoundingClientRect();
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        field.classList.add('drop-target');
      } else {
        field.classList.remove('drop-target');
      }
    }

    function tryDrop(x, y) {
      const field = document.getElementById('playerField');
      const rect = field.getBoundingClientRect();
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        const card = game.player.hand[dragState.cardIndex];
        if (card && card.cost <= game.mana) {
          game.mana -= card.cost;
          const newCard = { ...card, currentHp: card.hp, canAttack: false, bonusAtk: 0 };
          
          // Fargate ì¦‰ì‹œ ê³µê²© ê°€ëŠ¥
          if (card.id === 'fargate') {
            newCard.canAttack = true;
            addLog(`ğŸš€ Fargate ì¦‰ì‹œ ë°°ì¹˜!`, 'info');
          }
          
          game.player.field.push(newCard);
          game.player.hand.splice(dragState.cardIndex, 1);
          
          // ì‹œë„ˆì§€ íš¨ê³¼ ì ìš©
          applySynergyEffects();
          
          addLog(`${card.icon} ${card.name} ë°°ì¹˜!`, 'info');
          updateBattleUI();
        }
      }
    }

    // ========== ì´ˆê¸°í™” ==========
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');
      });
    });

    document.querySelectorAll('.filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        renderCardGrid(btn.dataset.filter);
      });
    });

    renderCardGrid();
  </script>
</body>
</html>
