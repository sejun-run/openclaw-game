<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="theme-color" content="#1a1a2e">
  <link rel="manifest" href="manifest.json">
  <link rel="apple-touch-icon" href="icon-192.png">
  <title>ì„œë²„ ë””íœìŠ¤ - ì¸í”„ë¼ ì¹´ë“œê²Œì„</title>
  <script>
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js').catch(() => {});
    }
  </script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    html, body {
      min-height: 100%;
      margin: 0;
      padding: 0;
    }
    
    body {
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      color: #eee;
      font-family: 'Segoe UI', sans-serif;
      -webkit-overflow-scrolling: touch;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      -webkit-touch-callout: none;
      -webkit-tap-highlight-color: transparent;
    }

    /* ë©”ì¸ ì»¨í…Œì´ë„ˆ */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 10px;
    }

    /* ê²Œì„ ëª¨ë“œ: ì „ì²´ í™”ë©´ ê³ ì •, ìŠ¤í¬ë¡¤/ë“œë˜ê·¸ ë°©ì§€ */
    body.game-mode {
      overflow: hidden;
      position: fixed;
      width: 100%;
      height: 100%;
      height: 100dvh;
      touch-action: none;
    }

    body.game-mode .container {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      max-width: 100%;
      padding: 3px;
      padding-top: env(safe-area-inset-top, 3px);
      padding-bottom: env(safe-area-inset-bottom, 3px);
      display: flex;
      flex-direction: column;
    }

    header {
      text-align: center;
      padding: 15px 0;
      margin-bottom: 15px;
    }

    body.game-mode header { display: none; }

    h1 {
      font-size: 2.2em;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 5px;
    }

    .subtitle { color: #888; font-size: 1em; }

    /* íƒ­ */
    .tabs {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-bottom: 20px;
    }

    body.game-mode .tabs { display: none; }

    .tab-btn {
      padding: 12px 30px;
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 25px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s;
      font-size: 1em;
    }

    .tab-btn:hover, .tab-btn.active {
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      color: #000;
      border-color: transparent;
    }

    .tab-content { display: none; }
    .tab-content.active { display: block; }

    /* ========== ë„ê° ìŠ¤íƒ€ì¼ ========== */
    .filters {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 8px;
      margin-bottom: 20px;
    }

    /* ë± í•„í„° (ìƒë‹¨) */
    .deck-filters {
      display: flex;
      justify-content: center;
      gap: 8px;
      margin-bottom: 15px;
      flex-wrap: wrap;
    }

    .deck-filter-btn {
      padding: 10px 18px;
      background: rgba(255,255,255,0.08);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 25px;
      color: #ccc;
      cursor: pointer;
      font-size: 0.95em;
      font-weight: 500;
      transition: all 0.3s;
    }

    .deck-filter-btn:hover {
      background: rgba(0, 255, 136, 0.15);
      border-color: #00ff88;
      color: #fff;
    }

    .deck-filter-btn.active {
      background: linear-gradient(135deg, #00ff88, #00d9ff);
      border-color: transparent;
      color: #000;
      font-weight: bold;
    }

    /* ì¹´í…Œê³ ë¦¬ í•„í„° (í•˜ë‹¨) */
    .filter-btn {
      padding: 8px 16px;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 20px;
      color: #aaa;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.3s;
    }

    .filter-btn:hover, .filter-btn.active {
      background: rgba(0, 217, 255, 0.2);
      border-color: #00d9ff;
      color: #fff;
    }

    .card-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
      gap: 15px;
    }

    .card-item {
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border-radius: 12px;
      padding: 15px;
      cursor: pointer;
      transition: all 0.3s;
      border: 2px solid transparent;
    }

    .card-item:hover {
      transform: translateY(-5px);
      border-color: #00d9ff;
      box-shadow: 0 10px 30px rgba(0, 217, 255, 0.3);
    }

    .card-item .icon { font-size: 2.5em; text-align: center; margin-bottom: 10px; }
    .card-item .name { font-weight: bold; text-align: center; margin-bottom: 5px; }
    .card-item .category { font-size: 0.8em; color: #888; text-align: center; }

    .card-item .stats {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin-top: 10px;
      font-size: 0.85em;
    }

    .card-item .cost { color: #3498db; }
    .card-item .atk { color: #e74c3c; }
    .card-item .hp { color: #2ecc71; }

    /* ì¹´ë“œ ìƒì„¸ ëª¨ë‹¬ */
    .modal-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.85);
      z-index: 1000;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }

    .modal-overlay.active { display: flex; }

    .modal-content {
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border-radius: 15px;
      padding: 25px;
      max-width: 400px;
      width: 100%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-content .icon { font-size: 4em; text-align: center; margin-bottom: 15px; }
    .modal-content .name { font-size: 1.5em; font-weight: bold; text-align: center; }
    .modal-content .category { color: #888; text-align: center; margin-bottom: 15px; }

    .modal-content .stats-row {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin-bottom: 20px;
    }

    .modal-content .stat-box {
      background: rgba(0,0,0,0.3);
      padding: 10px 20px;
      border-radius: 10px;
      text-align: center;
    }

    .modal-content .stat-value { font-size: 1.3em; font-weight: bold; }
    .modal-content .stat-label { font-size: 0.75em; color: #888; }

    .modal-content .description {
      color: #ccc;
      line-height: 1.6;
      margin-bottom: 15px;
    }

    .modal-content .effect {
      background: rgba(0, 217, 255, 0.1);
      border-left: 3px solid #00d9ff;
      padding: 12px;
      margin-bottom: 15px;
      border-radius: 0 8px 8px 0;
    }

    .modal-content .services {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
      margin-bottom: 20px;
    }

    .modal-content .service-tag {
      background: rgba(255,255,255,0.1);
      padding: 5px 12px;
      border-radius: 15px;
      font-size: 0.8em;
    }

    .modal-content .close-btn {
      display: block;
      width: 100%;
      padding: 12px;
      background: linear-gradient(90deg, #00d9ff, #00ff88);
      border: none;
      border-radius: 25px;
      color: #000;
      font-weight: bold;
      cursor: pointer;
    }

    /* ========== ê²Œì„ ìŠ¤íƒ€ì¼ ========== */
    .game-start {
      text-align: center;
      padding: 40px 20px;
    }

    .game-start h2 { font-size: 1.8em; margin-bottom: 15px; color: #00d9ff; }
    .game-start p { color: #888; margin-bottom: 20px; }

    /* ë± ì„ íƒ */
    .deck-select { margin-bottom: 20px; }
    .deck-btns {
      display: flex;
      justify-content: center;
      gap: 10px;
      flex-wrap: wrap;
      margin-bottom: 10px;
    }
    .deck-btn {
      padding: 12px 16px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.15);
      border-radius: 12px;
      cursor: pointer;
      transition: all 0.3s;
      text-align: center;
      min-width: 80px;
    }
    .deck-btn:hover {
      border-color: #00d9ff;
      background: rgba(0, 217, 255, 0.1);
    }
    .deck-btn.active {
      border-color: #00ff88;
      background: rgba(0, 255, 136, 0.15);
    }
    .deck-icon { font-size: 1.5em; display: block; margin-bottom: 5px; }
    .deck-name { font-size: 0.85em; color: #ccc; }
    .deck-desc { font-size: 0.9em; color: #888; font-style: italic; }

    .difficulty-btns {
      display: flex;
      justify-content: center;
      gap: 15px;
      flex-wrap: wrap;
    }

    .diff-btn {
      padding: 20px 30px;
      background: rgba(255,255,255,0.05);
      border: 2px solid rgba(255,255,255,0.1);
      border-radius: 15px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s;
    }

    .diff-btn:hover {
      border-color: #00d9ff;
      background: rgba(0, 217, 255, 0.1);
    }

    .diff-btn h3 { margin-bottom: 5px; }
    .diff-btn p { font-size: 0.85em; color: #888; margin: 0; }

    /* ========== ì „íˆ¬ í™”ë©´ - ì„¸ë¡œëª¨ë“œ ê¸°ì¤€ ========== */
    .battle-screen {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      flex-direction: column;
      justify-content: space-between;
      overflow: hidden;
      padding: 15px;
      padding-top: max(20px, env(safe-area-inset-top));
      padding-bottom: max(20px, env(safe-area-inset-bottom));
    }

    body.game-mode .battle-screen { display: flex; }

    /* ì  ì˜ì—­ (ìƒë‹¨) - ì»´íŒ©íŠ¸ */
    .enemy-side {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      padding: 8px;
      background: rgba(231, 76, 60, 0.15);
      border-radius: 12px;
      border: 1px solid rgba(231, 76, 60, 0.3);
    }

    .enemy-field {
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      gap: 5px;
      min-height: 75px;
      width: 100%;
    }

    /* ì•„ë°”íƒ€ (HP í‘œì‹œ) - ê°€ë¡œí˜• */
    .avatar {
      display: flex;
      align-items: center;
      gap: 10px;
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border: 3px solid #ff6b6b;
      border-radius: 12px;
      padding: 8px 15px;
    }

    .avatar.player {
      border-color: #4ecdc4;
    }

    .avatar .icon {
      font-size: 1.8em;
    }

    .avatar .hp-info {
      display: flex;
      flex-direction: column;
      gap: 3px;
    }

    .avatar .hp-text {
      font-size: 1em;
      font-weight: bold;
    }

    .avatar .hp-bar-mini {
      width: 80px;
      height: 8px;
      background: #333;
      border-radius: 4px;
      overflow: hidden;
    }

    .avatar .hp-fill {
      height: 100%;
      background: linear-gradient(90deg, #27ae60, #2ecc71);
      transition: width 0.3s;
    }

    .avatar .hp-fill.low {
      background: linear-gradient(90deg, #c0392b, #e74c3c);
    }

    /* ê°€ìš´ë°: VS + ë¡œê·¸ + ë§ˆë‚˜ */
    .center-area {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 8px;
      padding: 10px 0;
      min-height: 0;
    }

    .center-top {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 15px;
    }

    .vs-badge {
      padding: 6px 15px;
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border-radius: 15px;
      font-size: 0.9em;
      font-weight: bold;
    }

    .mana-display {
      display: flex;
      align-items: center;
      gap: 5px;
      background: rgba(0, 150, 255, 0.4);
      padding: 6px 12px;
      border-radius: 12px;
      font-weight: bold;
      font-size: 0.9em;
    }

    /* ë‚´ ì˜ì—­ - ì»´íŒ©íŠ¸ */
    .my-side {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
      padding: 8px;
      background: rgba(78, 205, 196, 0.15);
      border-radius: 12px;
      border: 1px solid rgba(78, 205, 196, 0.3);
    }

    .my-field {
      display: flex;
      flex-wrap: nowrap;
      justify-content: center;
      gap: 5px;
      min-height: 75px;
      width: 100%;
    }

    /* í•˜ë‹¨ íŒ¨ë„: í•¸ë“œ + ë²„íŠ¼ */
    .bottom-panel {
      flex: 0 0 auto;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
    }

    .hand-area {
      display: flex;
      justify-content: center;
      width: 100%;
    }

    .controls-bar {
      display: flex;
      justify-content: center;
      gap: 20px;
      padding: 8px 0;
    }

    .controls-bar .btn {
      padding: 8px 20px;
      font-size: 0.85em;
      min-width: 80px;
    }

    /* í„´ ì¢…ë£Œ ë²„íŠ¼ - ëˆˆì— ë„ëŠ” ìƒ‰ìƒ */
    #endTurnBtn {
      background: linear-gradient(135deg, #e67e22, #f39c12);
      color: #fff;
      font-weight: bold;
      border: 2px solid #f39c12;
      transition: all 0.3s;
    }

    #endTurnBtn:hover {
      background: linear-gradient(135deg, #d35400, #e67e22);
      transform: scale(1.05);
    }

    /* í•  ë™ì‘ ì—†ì„ ë•Œë§Œ ë¹›ë‚˜ê²Œ */
    #endTurnBtn.highlight {
      animation: btnPulse 1.5s infinite;
      box-shadow: 0 0 20px rgba(243, 156, 18, 0.8);
    }

    @keyframes btnPulse {
      0%, 100% { box-shadow: 0 0 10px rgba(243, 156, 18, 0.5); }
      50% { box-shadow: 0 0 25px rgba(243, 156, 18, 1); }
    }

    /* ê³µê²© ì¤‘ì¸ ì¹´ë“œ */
    .field-card.attacking-source {
      border-color: #f1c40f !important;
      box-shadow: 0 0 20px rgba(241, 196, 15, 0.8);
      transform: scale(1.1);
    }

    /* ê³µê²© ëŒ€ìƒ */
    .field-card.attack-target,
    .avatar.attack-target {
      animation: targetPulse 0.5s infinite;
      border-color: #e74c3c !important;
    }

    .field-placeholder { color: #666; font-size: 0.8em; }

    /* í•¸ë“œ - ì„¸ë¡œëª¨ë“œ */
    .hand {
      display: flex;
      justify-content: center;
      align-items: flex-end;
      flex-wrap: wrap;
      gap: 5px;
    }

    .hand-card {
      width: 65px;
      height: 85px;
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border: 2px solid #444;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      margin: 0 -10px;
      transform-origin: bottom center;
    }

    .hand-card:hover {
      transform: translateY(-25px) scale(1.1);
      z-index: 100;
      border-color: #00d9ff;
      box-shadow: 0 15px 40px rgba(0, 217, 255, 0.4);
    }

    .hand-card.selected {
      transform: translateY(-35px) scale(1.15);
      z-index: 101;
      border-color: #00ff88;
      box-shadow: 0 20px 50px rgba(0, 255, 136, 0.5);
    }

    .hand-card.disabled { opacity: 0.5; }
    .hand-card.dragging { opacity: 0.3; }
    
    /* êµ¬ë§¤ ê°€ëŠ¥í•œ ì¹´ë“œ í•˜ì´ë¼ì´íŠ¸ */
    .hand-card.playable {
      border-color: #00ff88;
      box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
    }

    .hand-card .cost {
      position: absolute;
      top: -8px;
      left: 50%;
      transform: translateX(-50%);
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #3498db, #2980b9);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.75em;
      font-weight: bold;
      border: 2px solid #fff;
      z-index: 10;
    }

    .hand-card .icon { font-size: 1.8em; }
    .hand-card .name { font-size: 0.6em; margin-top: 3px; }

    .hand-card .card-stats {
      display: flex;
      gap: 8px;
      font-size: 0.6em;
      margin-top: 3px;
    }

    /* í•„ë“œ ì¹´ë“œ - ì„¸ë¡œëª¨ë“œ */
    .field-card {
      width: 60px;
      height: 75px;
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border: 2px solid #555;
      border-radius: 6px;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      padding-top: 5px;
      cursor: pointer;
      position: relative;
      transition: all 0.2s;
    }

    /* ë°ìŠ¤í¬í†±ì—ì„œë§Œ hover íš¨ê³¼ */
    @media (hover: hover) {
      .field-card:hover {
        border-color: #00d9ff;
        transform: scale(1.05);
      }
    }

    .field-card.can-attack {
      border-color: #00ff88;
      box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {
      0%, 100% { box-shadow: 0 0 8px rgba(0, 255, 136, 0.5); }
      50% { box-shadow: 0 0 20px rgba(0, 255, 136, 0.8); }
    }

    @keyframes floatUp {
      0% { opacity: 1; transform: translateX(-50%) translateY(0); }
      100% { opacity: 0; transform: translateX(-50%) translateY(-50px); }
    }

    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px) rotate(-2deg); }
      75% { transform: translateX(5px) rotate(2deg); }
    }

    .field-card.attacking {
      animation: shake 0.3s ease-in-out;
    }

    @keyframes glow {
      0%, 100% { box-shadow: 0 0 5px rgba(0, 217, 255, 0.5); }
      50% { box-shadow: 0 0 20px rgba(0, 217, 255, 1); }
    }

    .field-card.synergy {
      animation: glow 2s infinite;
      border-color: #00d9ff;
    }

    /* ê³µê²© ëŒ€ìƒ í•˜ì´ë¼ì´íŠ¸ */
    .field-card.attack-target,
    .hp-bar.attack-target {
      animation: targetPulse 0.5s infinite;
      border-color: #e74c3c !important;
    }

    @keyframes targetPulse {
      0%, 100% { box-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
      50% { box-shadow: 0 0 25px rgba(231, 76, 60, 1); }
    }

    .field-card .icon { font-size: 1.8em; line-height: 1; }
    .field-card .name { 
      font-size: 0.5em; 
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-top: 2px;
      opacity: 0.9;
    }

    .field-card .card-atk {
      position: absolute;
      bottom: -5px;
      left: -5px;
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      border-radius: 50%;
      font-size: 0.65em;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #1a1a2e;
    }

    .field-card .card-hp {
      position: absolute;
      bottom: -5px;
      right: -5px;
      width: 22px;
      height: 22px;
      background: linear-gradient(135deg, #27ae60, #1e8449);
      border-radius: 50%;
      font-size: 0.65em;
      font-weight: bold;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 2px solid #1a1a2e;
    }

    /* ì»¨íŠ¸ë¡¤ ë²„íŠ¼ */
    .controls {
      display: flex;
      justify-content: center;
      gap: 8px;
    }

    .btn {
      padding: 6px 16px;
      border: none;
      border-radius: 15px;
      font-weight: bold;
      font-size: 0.8em;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-primary {
      background: linear-gradient(135deg, #00d9ff, #00ff88);
      color: #000;
    }

    .btn-danger {
      background: linear-gradient(135deg, #e74c3c, #c0392b);
      color: #fff;
    }

    .btn-back {
      background: rgba(255,255,255,0.1);
      color: #fff;
    }

    .btn:active { transform: scale(0.95); }

    /* ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ */
    .drag-ghost {
      position: fixed;
      pointer-events: none;
      z-index: 9999;
      opacity: 0.9;
      transform: translate(-50%, -50%) scale(1.1);
    }

    .drag-ghost .hand-card {
      margin: 0;
      box-shadow: 0 20px 60px rgba(0, 217, 255, 0.6);
      border-color: #00d9ff;
    }

    .battle-field.drop-target {
      background: rgba(0, 255, 136, 0.2);
      border: 2px dashed #00ff88;
    }

    /* ë°°í‹€ ë¡œê·¸ - ì—¬ëŸ¬ ì¤„ + ìŠ¤í¬ë¡¤ */
    .battle-log {
      flex: 1;
      background: rgba(0,0,0,0.5);
      padding: 8px 12px;
      border-radius: 10px;
      font-size: 0.85em;
      min-height: 60px;
      overflow-y: auto;
      border: 1px solid rgba(255,255,255,0.1);
    }

    .log-entry { 
      padding: 3px 0; 
      color: #ccc;
      border-bottom: 1px solid rgba(255,255,255,0.05);
    }
    .log-entry:last-child {
      border-bottom: none;
    }
    .log-entry.damage { 
      color: #ff6b6b; 
      font-weight: bold;
    }
    .log-entry.info { 
      color: #4ecdc4; 
    }

    /* ê²Œì„ ì˜¤ë²„ */
    .game-over {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 2000;
      justify-content: center;
      align-items: center;
      text-align: center;
    }

    .game-over.active { display: flex; }
    .game-over h2 { font-size: 2.5em; margin-bottom: 20px; }
    .game-over.win h2 { color: #00ff88; }
    .game-over.lose h2 { color: #e74c3c; }
    .game-over p { color: #888; margin-bottom: 30px; }

    /* ë°˜ì‘í˜• */
    @media (max-width: 600px) {
      h1 { font-size: 1.8em; }
      .card-grid { grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 10px; }
      .hand-card { width: 60px; height: 80px; margin: 0 -10px; }
      .hand-card .icon { font-size: 1.6em; }
    }

    /* ========== íŠœí† ë¦¬ì–¼ ìŠ¤íƒ€ì¼ ========== */
    .tutorial-overlay {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.8);
      z-index: 3000;
      justify-content: center;
      align-items: center;
      padding: 20px;
    }
    .tutorial-overlay.active { display: flex; }

    .tutorial-box {
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border: 2px solid #00d9ff;
      border-radius: 15px;
      padding: 25px;
      max-width: 350px;
      width: 100%;
      text-align: center;
      animation: tutorialPop 0.3s ease-out;
    }

    @keyframes tutorialPop {
      0% { transform: scale(0.8); opacity: 0; }
      100% { transform: scale(1); opacity: 1; }
    }

    .tutorial-box h3 {
      color: #00d9ff;
      margin-bottom: 15px;
      font-size: 1.3em;
    }

    .tutorial-box p {
      color: #ccc;
      line-height: 1.6;
      margin-bottom: 20px;
    }

    .tutorial-box .step-indicator {
      color: #888;
      font-size: 0.85em;
      margin-bottom: 15px;
    }

    .tutorial-buttons {
      display: flex;
      gap: 10px;
      justify-content: center;
    }

    .tutorial-highlight {
      position: relative;
      z-index: 3001;
      animation: tutorialGlow 1s infinite;
    }

    @keyframes tutorialGlow {
      0%, 100% { box-shadow: 0 0 10px #00d9ff, 0 0 20px #00d9ff; }
      50% { box-shadow: 0 0 20px #00d9ff, 0 0 40px #00d9ff; }
    }

    .tutorial-arrow {
      position: fixed;
      font-size: 2em;
      color: #00d9ff;
      z-index: 3002;
      animation: bounce 1s infinite;
      text-shadow: 0 0 10px #00d9ff;
    }

    @keyframes bounce {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }

    /* ë„ì›€ë§ ë²„íŠ¼ */
    .help-btn {
      position: fixed;
      bottom: 20px;
      right: 20px;
      width: 50px;
      height: 50px;
      background: linear-gradient(135deg, #00d9ff, #00ff88);
      border: none;
      border-radius: 50%;
      color: #000;
      font-size: 1.5em;
      font-weight: bold;
      cursor: pointer;
      z-index: 2500;
      box-shadow: 0 4px 15px rgba(0, 217, 255, 0.4);
      display: none;
    }

    body.game-mode .help-btn { display: flex; justify-content: center; align-items: center; }

    .help-btn:active { transform: scale(0.95); }

    /* ë„ì›€ë§ ëª¨ë‹¬ */
    .help-modal {
      display: none;
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0,0,0,0.9);
      z-index: 2600;
      justify-content: center;
      align-items: center;
      padding: 15px;
    }

    .help-modal.active { display: flex; }

    .help-content {
      background: linear-gradient(145deg, #2a2a5a, #1a1a3e);
      border-radius: 15px;
      padding: 20px;
      max-width: 400px;
      width: 100%;
      max-height: 80vh;
      overflow-y: auto;
    }

    .help-content h3 {
      color: #00d9ff;
      margin-bottom: 15px;
      text-align: center;
    }

    .help-section {
      margin-bottom: 20px;
    }

    .help-section h4 {
      color: #00ff88;
      margin-bottom: 10px;
      font-size: 1em;
    }

    .help-section ul {
      list-style: none;
      padding: 0;
    }

    .help-section li {
      color: #ccc;
      padding: 8px 0;
      border-bottom: 1px solid rgba(255,255,255,0.1);
      font-size: 0.9em;
    }

    .help-section li:last-child { border-bottom: none; }

    .help-section li strong { color: #fff; }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>ğŸƒ ì„œë²„ ë””íœìŠ¤</h1>
      <p class="subtitle">ì¸í”„ë¼ ì¹´ë“œê²Œì„ìœ¼ë¡œ ë°°ìš°ëŠ” í´ë¼ìš°ë“œ ì•„í‚¤í…ì²˜</p>
    </header>

    <div class="tabs">
      <button class="tab-btn active" data-tab="collection">ğŸ“š ì¹´ë“œ ë„ê°</button>
      <button class="tab-btn" data-tab="game">ğŸ® ê²Œì„í•˜ê¸°</button>
    </div>

    <!-- ë„ê° íƒ­ -->
    <div id="collection" class="tab-content active">
      <!-- ë± ì„ íƒ -->
      <div class="deck-filters">
        <button class="deck-filter-btn active" data-deck="all">ğŸ“š ì „ì²´</button>
        <button class="deck-filter-btn" data-deck="infra">ğŸ–¥ï¸ ì¸í”„ë¼</button>
        <button class="deck-filter-btn" data-deck="datastructure">ğŸ“Š ìë£Œêµ¬ì¡°</button>
        <button class="deck-filter-btn" data-deck="os">âš™ï¸ ìš´ì˜ì²´ì œ</button>
        <button class="deck-filter-btn" data-deck="algorithm">ğŸ§® ì•Œê³ ë¦¬ì¦˜</button>
      </div>
      <!-- ì¹´í…Œê³ ë¦¬ í•„í„° (ë±ì— ë”°ë¼ ë™ì  ë³€ê²½) -->
      <div class="filters" id="categoryFilters">
        <button class="filter-btn active" data-filter="all">ì „ì²´</button>
      </div>
      <div class="card-grid" id="cardGrid"></div>
    </div>

    <!-- ê²Œì„ íƒ­ -->
    <div id="game" class="tab-content">
      <div class="game-start" id="gameStart">
        <h2>ğŸš€ ì„œë²„ë¥¼ ì§€ì¼œë¼!</h2>
        <p>ì¹´ë“œë¡œ ì„œë²„ë¥¼ êµ¬ì¶•í•˜ê³  ì ì˜ ê³µê²©ìœ¼ë¡œë¶€í„° ë°©ì–´í•˜ì„¸ìš”!</p>
        
        <!-- ë± ì„ íƒ -->
        <div class="deck-select">
          <h3 style="margin-bottom: 15px;">ğŸ“š ë± ì„ íƒ</h3>
          <div class="deck-btns">
            <div class="deck-btn active" data-deck="infra" onclick="selectDeck('infra')">
              <span class="deck-icon">ğŸ–¥ï¸</span>
              <span class="deck-name">ì¸í”„ë¼</span>
            </div>
            <div class="deck-btn" data-deck="datastructure" onclick="selectDeck('datastructure')">
              <span class="deck-icon">ğŸ“Š</span>
              <span class="deck-name">ìë£Œêµ¬ì¡°</span>
            </div>
            <div class="deck-btn" data-deck="os" onclick="selectDeck('os')">
              <span class="deck-icon">âš™ï¸</span>
              <span class="deck-name">ìš´ì˜ì²´ì œ</span>
            </div>
            <div class="deck-btn" data-deck="algorithm" onclick="selectDeck('algorithm')">
              <span class="deck-icon">ğŸ§®</span>
              <span class="deck-name">ì•Œê³ ë¦¬ì¦˜</span>
            </div>
          </div>
          <p class="deck-desc" id="deckDesc">í´ë¼ìš°ë“œ ì„œë¹„ìŠ¤ ì¹´ë“œë¡œ ì•ˆì •ì ì¸ ì„œë²„ êµ¬ì¶•</p>
        </div>

        <h3 style="margin: 20px 0 15px;">âš”ï¸ ë‚œì´ë„</h3>
        <div class="difficulty-btns">
          <div class="diff-btn" onclick="startGame('easy')">
            <h3>ğŸŸ¢ ì‰¬ì›€</h3>
            <p>ì…ë¬¸ììš©</p>
          </div>
          <div class="diff-btn" onclick="startGame('normal')">
            <h3>ğŸŸ¡ ë³´í†µ</h3>
            <p>ê¸°ë³¸</p>
          </div>
          <div class="diff-btn" onclick="startGame('hard')">
            <h3>ğŸ”´ ì–´ë ¤ì›€</h3>
            <p>ë„ì „!</p>
          </div>
        </div>
        <p style="margin-top: 20px; color: #666; font-size: 0.9em;">
          <span onclick="resetTutorial()" style="cursor: pointer; text-decoration: underline;">ğŸ“– íŠœí† ë¦¬ì–¼ ë‹¤ì‹œ ë³´ê¸°</span>
        </p>
      </div>
    </div>

    <!-- ì „íˆ¬ í™”ë©´ - ì»´íŒ©íŠ¸ ì„¸ë¡œ ë ˆì´ì•„ì›ƒ -->
    <div class="battle-screen" id="battleScreen">
      <!-- ì  ì˜ì—­ (ìƒë‹¨): ì•„ë°”íƒ€ | ì ì¹´ë“œë“¤ -->
      <div class="enemy-side">
        <div class="avatar" id="enemyAvatar">
          <span class="icon">ğŸ¤–</span>
          <div class="hp-info">
            <span class="hp-text" id="enemyHpText">100</span>
            <div class="hp-bar-mini">
              <div class="hp-fill" id="enemyHpFill"></div>
            </div>
          </div>
        </div>
        <div class="enemy-field" id="enemyField"></div>
      </div>

      <!-- ê°€ìš´ë°: VS + ë§ˆë‚˜ (ìƒë‹¨) + ë¡œê·¸ (í™•ì¥) -->
      <div class="center-area">
        <div class="center-top">
          <div class="vs-badge">âš”ï¸</div>
          <div class="mana-display">
            <span>âš¡</span>
            <span id="manaText">1/1</span>
          </div>
        </div>
        <div class="battle-log" id="battleLog"></div>
      </div>

      <!-- ë‚´ ì˜ì—­: ë‚´ì¹´ë“œë“¤ | ì•„ë°”íƒ€ -->
      <div class="my-side">
        <div class="my-field" id="playerField"></div>
        <div class="avatar player" id="playerAvatar">
          <span class="icon">ğŸ‘¤</span>
          <div class="hp-info">
            <span class="hp-text" id="playerHpText">100</span>
            <div class="hp-bar-mini">
              <div class="hp-fill" id="playerHpFill"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- í•˜ë‹¨: í•¸ë“œ + ë²„íŠ¼ -->
      <div class="bottom-panel">
        <div class="hand-area">
          <div class="hand" id="playerHand"></div>
        </div>
        <div class="controls-bar">
          <button class="btn btn-back" onclick="exitGame()">ë‚˜ê°€ê¸°</button>
          <button class="btn btn-primary" id="endTurnBtn" onclick="endTurn()">í„´ ì¢…ë£Œ</button>
        </div>
      </div>
    </div>
  </div>

  <!-- ì¹´ë“œ ìƒì„¸ ëª¨ë‹¬ -->
  <div class="modal-overlay" id="modalOverlay" onclick="closeModal(event)">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="icon" id="modalIcon">ğŸ–¥ï¸</div>
      <div class="name" id="modalName">EC2</div>
      <div class="category" id="modalCategory">ì»´í“¨íŒ…</div>
      <div class="stats-row">
        <div class="stat-box">
          <div class="stat-value" id="modalCost">3</div>
          <div class="stat-label">ì½”ìŠ¤íŠ¸</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="modalHp">100</div>
          <div class="stat-label">HP</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="modalAtk">20</div>
          <div class="stat-label">ê³µê²©ë ¥</div>
        </div>
      </div>
      <div class="description" id="modalDesc">ì„¤ëª…</div>
      <div class="effect" id="modalEffect">ğŸ’¡ íš¨ê³¼</div>
      <div class="services" id="modalServices"></div>
      <button class="close-btn" onclick="closeModal()">ë‹«ê¸°</button>
    </div>
  </div>

  <!-- ê²Œì„ ì¤‘ ì¹´ë“œ ìƒì„¸ -->
  <div class="modal-overlay" id="gameCardModal" onclick="closeGameCardModal(event)">
    <div class="modal-content" onclick="event.stopPropagation()">
      <div class="icon" id="gameCardIcon">ğŸ–¥ï¸</div>
      <div class="name" id="gameCardName">EC2</div>
      <div class="category" id="gameCardCategory">ì»´í“¨íŒ…</div>
      <div class="stats-row">
        <div class="stat-box">
          <div class="stat-value" id="gameCardCost">3</div>
          <div class="stat-label">ì½”ìŠ¤íŠ¸</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="gameCardHp">100</div>
          <div class="stat-label">HP</div>
        </div>
        <div class="stat-box">
          <div class="stat-value" id="gameCardAtk">20</div>
          <div class="stat-label">ê³µê²©ë ¥</div>
        </div>
      </div>
      <div class="description" id="gameCardDesc">ì„¤ëª…</div>
      <div class="effect" id="gameCardEffect">ğŸ’¡ íš¨ê³¼</div>
      <div id="gameCardActions" style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;"></div>
    </div>
  </div>

  <!-- ë“œë˜ê·¸ ê³ ìŠ¤íŠ¸ -->
  <div class="drag-ghost" id="dragGhost" style="display: none;"></div>

  <!-- ê²Œì„ ì˜¤ë²„ -->
  <div class="game-over" id="gameOver">
    <div>
      <h2 id="gameOverTitle">ìŠ¹ë¦¬!</h2>
      <p id="gameOverMsg">ìƒëŒ€ ì„œë²„ë¥¼ ë‹¤ìš´ì‹œì¼°ìŠµë‹ˆë‹¤!</p>
      <button class="btn btn-primary" onclick="restartGame()">ë‹¤ì‹œ í•˜ê¸°</button>
    </div>
  </div>

  <!-- íŠœí† ë¦¬ì–¼ ì˜¤ë²„ë ˆì´ -->
  <div class="tutorial-overlay" id="tutorialOverlay">
    <div class="tutorial-box">
      <div class="step-indicator" id="tutorialStep">1/5</div>
      <h3 id="tutorialTitle">ğŸ® ì„œë²„ ë””íœìŠ¤ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!</h3>
      <p id="tutorialText">ì¸í”„ë¼ ì¹´ë“œë¥¼ ë°°ì¹˜í•˜ê³  ì ì˜ ê³µê²©ìœ¼ë¡œë¶€í„° ì„œë²„ë¥¼ ì§€í‚¤ì„¸ìš”!</p>
      <div class="tutorial-buttons">
        <button class="btn btn-back" id="tutorialSkip" onclick="skipTutorial()">ê±´ë„ˆë›°ê¸°</button>
        <button class="btn btn-primary" id="tutorialNext" onclick="nextTutorialStep()">ë‹¤ìŒ</button>
      </div>
    </div>
  </div>

  <!-- ë„ì›€ë§ ë²„íŠ¼ -->
  <button class="help-btn" id="helpBtn" onclick="toggleHelp()">?</button>

  <!-- ë„ì›€ë§ ëª¨ë‹¬ -->
  <div class="help-modal" id="helpModal" onclick="closeHelp(event)">
    <div class="help-content" onclick="event.stopPropagation()">
      <h3>ğŸ“– ê²Œì„ ë„ì›€ë§</h3>
      
      <div class="help-section">
        <h4>ğŸ¯ ëª©í‘œ</h4>
        <ul>
          <li>ì  ì„œë²„ì˜ <strong>HPë¥¼ 0</strong>ìœ¼ë¡œ ë§Œë“¤ë©´ ìŠ¹ë¦¬!</li>
          <li>ë‚´ ì„œë²„ HPê°€ 0ì´ ë˜ë©´ íŒ¨ë°°</li>
        </ul>
      </div>

      <div class="help-section">
        <h4>ğŸƒ ì¹´ë“œ ì¡°ì‘</h4>
        <ul>
          <li><strong>íƒ­/í´ë¦­</strong> â†’ ì¹´ë“œ ìƒì„¸ ì •ë³´</li>
          <li><strong>ë“œë˜ê·¸</strong> â†’ í•¸ë“œ ì¹´ë“œë¥¼ í•„ë“œì— ë°°ì¹˜</li>
          <li><strong>í•„ë“œ ì¹´ë“œ ë“œë˜ê·¸</strong> â†’ ì ì—ê²Œ ê³µê²©</li>
        </ul>
      </div>

      <div class="help-section">
        <h4>âš¡ ë§ˆë‚˜ ì‹œìŠ¤í…œ</h4>
        <ul>
          <li>ë§¤í„´ ìµœëŒ€ ë§ˆë‚˜ê°€ <strong>+1</strong> ì¦ê°€ (ìµœëŒ€ 10)</li>
          <li>ì¹´ë“œ ë°°ì¹˜ì— ë§ˆë‚˜ ì†Œëª¨</li>
          <li>ë§ˆë‚˜ ë¶€ì¡± ì‹œ ì¹´ë“œ ë°°ì¹˜ ë¶ˆê°€</li>
        </ul>
      </div>

      <div class="help-section">
        <h4>âš”ï¸ ì „íˆ¬</h4>
        <ul>
          <li>ë°°ì¹˜ëœ ì¹´ë“œëŠ” <strong>ë‹¤ìŒ í„´</strong>ë¶€í„° ê³µê²© ê°€ëŠ¥</li>
          <li><strong>ì´ˆë¡ í…Œë‘ë¦¬</strong> = ê³µê²© ê°€ëŠ¥</li>
          <li>ì  ìœ ë‹›ì´ ì—†ìœ¼ë©´ ì§ì ‘ ê³µê²© ê°€ëŠ¥</li>
          <li>ì—°ì† ê³µê²© ì‹œ <strong>ì½¤ë³´ ë³´ë„ˆìŠ¤</strong> ë°œë™!</li>
        </ul>
      </div>

      <div class="help-section">
        <h4>ğŸ”— ì‹œë„ˆì§€</h4>
        <ul>
          <li><strong>Lambda + DynamoDB</strong> â†’ ê³µê²©ë ¥ +15</li>
          <li><strong>Docker + K8s</strong> â†’ ê³µê²©ë ¥ +10</li>
          <li><strong>EC2 + EBS</strong> â†’ HP +30</li>
          <li><strong>Route 53</strong> â†’ ëª¨ë“  ì•„êµ° ê³µê²©ë ¥ +5</li>
        </ul>
      </div>

      <button class="btn btn-primary" style="width: 100%; margin-top: 10px;" onclick="closeHelp()">ë‹«ê¸°</button>
    </div>
  </div>

  <script>
    // ì¹´ë“œ ë°ì´í„°
    const allCards = [
      { id: 'ec2', name: 'EC2', icon: 'ğŸ–¥ï¸', category: 'computing', cost: 3, hp: 100, attack: 20,
        desc: 'Elastic Compute Cloud. ê°€ìƒ ì„œë²„ì˜ ëŒ€ëª…ì‚¬. í•„ìš”í•  ë•Œ ë°”ë¡œ ìƒì„±í•˜ê³ , ì•ˆ ì“°ë©´ ì¢…ë£Œ. í´ë¼ìš°ë“œì˜ ê¸°ë³¸ ì»´í“¨íŒ… ë¦¬ì†ŒìŠ¤ì…ë‹ˆë‹¤.',
        effect: 'ê¸°ë³¸ ì„œë²„ ì¹´ë“œ. ì•ˆì •ì ì¸ HPë¡œ ì „ì„  ìœ ì§€ì— ì í•©.', services: ['AWS EC2', 'GCP Compute Engine', 'Azure VM'] },
      { id: 'lambda', name: 'Lambda', icon: 'Î»', category: 'computing', cost: 2, hp: 30, attack: 40,
        desc: 'ì„œë²„ë¦¬ìŠ¤ í•¨ìˆ˜. ì„œë²„ ê´€ë¦¬ ì—†ì´ ì½”ë“œë§Œ ì‹¤í–‰. ì‚¬ìš©í•œ ë§Œí¼ë§Œ ê³¼ê¸ˆë˜ëŠ” ì´ë²¤íŠ¸ ê¸°ë°˜ ì»´í“¨íŒ….',
        effect: 'HPëŠ” ë‚®ì§€ë§Œ ê³µê²©ë ¥ì´ ë†’ìŒ. ì†ê³µì— ìœ ë¦¬.', services: ['AWS Lambda', 'GCP Cloud Functions', 'Azure Functions'] },
      { id: 'k8s', name: 'Kubernetes', icon: 'â˜¸ï¸', category: 'computing', cost: 5, hp: 150, attack: 30,
        desc: 'ì»¨í…Œì´ë„ˆ ì˜¤ì¼€ìŠ¤íŠ¸ë ˆì´ì…˜ì˜ ì™•. ìˆ˜ì²œ ê°œì˜ ì»¨í…Œì´ë„ˆë¥¼ ìë™ìœ¼ë¡œ ë°°í¬, ìŠ¤ì¼€ì¼ë§, ê´€ë¦¬.',
        effect: 'ë†’ì€ HP. íŒŒê´´ë˜ì–´ë„ 50% í™•ë¥ ë¡œ Podê°€ ë¶€í™œ.', services: ['AWS EKS', 'GCP GKE', 'Azure AKS'] },
      { id: 'fargate', name: 'Fargate', icon: 'ğŸš€', category: 'computing', cost: 4, hp: 80, attack: 25,
        desc: 'ì„œë²„ë¦¬ìŠ¤ ì»¨í…Œì´ë„ˆ. EC2 ì¸ìŠ¤í„´ìŠ¤ ê´€ë¦¬ ì—†ì´ ì»¨í…Œì´ë„ˆ ì‹¤í–‰. K8së³´ë‹¤ ê°„í¸.',
        effect: 'ë°°ì¹˜ ì‹œ ì¦‰ì‹œ ê³µê²© ê°€ëŠ¥.', services: ['AWS Fargate', 'GCP Cloud Run'] },
      { id: 's3', name: 'S3', icon: 'ğŸª£', category: 'storage', cost: 2, hp: 200, attack: 0,
        desc: 'Simple Storage Service. ë¬´ì œí•œ ê°ì²´ ìŠ¤í† ë¦¬ì§€. 99.999999999% ë‚´êµ¬ì„±ì˜ ì „ì„¤.',
        effect: 'ê³µê²© ë¶ˆê°€. íŒŒê´´ ì‹œ ëª¨ë“  ì•„êµ° ì¹´ë“œ HP +20 íšŒë³µ.', services: ['AWS S3', 'GCP Cloud Storage', 'Azure Blob'] },
      { id: 'ebs', name: 'EBS', icon: 'ğŸ’¾', category: 'storage', cost: 2, hp: 60, attack: 10,
        desc: 'Elastic Block Store. EC2ì— ë¶™ì´ëŠ” SSD/HDD. ìŠ¤ëƒ…ìƒ·ìœ¼ë¡œ ë°±ì—… ê°€ëŠ¥.',
        effect: 'EC2ì™€ í•¨ê»˜ ë°°ì¹˜ ì‹œ EC2ì˜ HP +30.', services: ['AWS EBS', 'GCP Persistent Disk'] },
      { id: 'rds', name: 'RDS', icon: 'ğŸ—„ï¸', category: 'database', cost: 4, hp: 120, attack: 15,
        desc: 'Relational Database Service. MySQL, PostgreSQL, Oracle ë“± ê´€ë¦¬í˜• DB. ë°±ì—…, íŒ¨ì¹˜ ìë™í™”.',
        effect: 'ë†’ì€ HPë¡œ ì•ˆì •ì . ë§¤í„´ ìë™ HP +5 íšŒë³µ.', services: ['AWS RDS', 'GCP Cloud SQL', 'Azure SQL'] },
      { id: 'dynamodb', name: 'DynamoDB', icon: 'âš¡', category: 'database', cost: 3, hp: 70, attack: 25,
        desc: 'NoSQLì˜ ëíŒì™•. ë°€ë¦¬ì´ˆ ì§€ì—°ì‹œê°„, ë¬´í•œ ìŠ¤ì¼€ì¼. ì„œë²„ë¦¬ìŠ¤ì™€ ì°°ë–¡ê¶í•©.',
        effect: 'Lambdaì™€ í•¨ê»˜ ìˆìœ¼ë©´ ê³µê²©ë ¥ +15.', services: ['AWS DynamoDB', 'GCP Firestore'] },
      { id: 'redis', name: 'Redis', icon: 'ğŸ”´', category: 'database', cost: 3, hp: 50, attack: 35,
        desc: 'ì¸ë©”ëª¨ë¦¬ ìºì‹œì˜ ì™•. ë§ˆì´í¬ë¡œì´ˆ ì‘ë‹µì‹œê°„. ì„¸ì…˜, ìºì‹œ, ì‹¤ì‹œê°„ ë­í‚¹ì— í•„ìˆ˜.',
        effect: 'DB ì¹´ë“œ ì•ì— ë°°ì¹˜ ì‹œ ë°›ëŠ” ë°ë¯¸ì§€ 30% ê°ì†Œ.', services: ['AWS ElastiCache', 'GCP Memorystore'] },
      { id: 'elb', name: 'ELB', icon: 'âš–ï¸', category: 'network', cost: 3, hp: 80, attack: 10,
        desc: 'Elastic Load Balancer. íŠ¸ë˜í”½ì„ ì—¬ëŸ¬ ì„œë²„ì— ë¶„ì‚°. ê³ ê°€ìš©ì„±ì˜ í•µì‹¬.',
        effect: 'ì„œë²„ ì¹´ë“œ 2ê°œ ì´ìƒ ì‹œ ë°›ëŠ” ë°ë¯¸ì§€ ë¶„ì‚°.', services: ['AWS ALB/NLB', 'GCP Load Balancer'] },
      { id: 'cdn', name: 'CloudFront', icon: 'ğŸŒ', category: 'network', cost: 2, hp: 40, attack: 0,
        desc: 'CDN (Content Delivery Network). ì „ ì„¸ê³„ ì—£ì§€ ë¡œì¼€ì´ì…˜ì—ì„œ ì½˜í…ì¸  ìºì‹±. ë¹ ë¥¸ ì‘ë‹µì˜ ë¹„ê²°.',
        effect: 'íŠ¸ë˜í”½ ìŠ¤íŒŒì´í¬ ê³µê²© ë¬´íš¨í™”.', services: ['AWS CloudFront', 'GCP Cloud CDN', 'Cloudflare'] },
      { id: 'route53', name: 'Route 53', icon: 'ğŸ§­', category: 'network', cost: 2, hp: 50, attack: 5,
        desc: 'DNS ì„œë¹„ìŠ¤. ë„ë©”ì¸ ê´€ë¦¬, í—¬ìŠ¤ì²´í¬, ë¼ìš°íŒ… ì •ì±…. ì´ë¦„ì˜ ìœ ë˜ëŠ” DNS í¬íŠ¸ 53.',
        effect: 'í•„ë“œì— ìˆìœ¼ë©´ ëª¨ë“  ì•„êµ° ì¹´ë“œ ê³µê²© +5.', services: ['AWS Route 53', 'GCP Cloud DNS'] },
      { id: 'vpc', name: 'VPC', icon: 'ğŸ°', category: 'network', cost: 3, hp: 100, attack: 0,
        desc: 'Virtual Private Cloud. ë‚˜ë§Œì˜ ê°€ìƒ ë„¤íŠ¸ì›Œí¬. ì„œë¸Œë„·, ë³´ì•ˆê·¸ë£¹ìœ¼ë¡œ ì² ë²½ ë°©ì–´.',
        effect: 'ëª¨ë“  ì•„êµ°ì´ ë°›ëŠ” ë°ë¯¸ì§€ -5.', services: ['AWS VPC', 'GCP VPC', 'Azure VNet'] },
      { id: 'waf', name: 'WAF', icon: 'ğŸ›¡ï¸', category: 'security', cost: 3, hp: 60, attack: 0,
        desc: 'Web Application Firewall. SQL Injection, XSS ë“± ì›¹ ê³µê²© ì°¨ë‹¨. ë³´ì•ˆì˜ ìµœì „ì„ .',
        effect: 'SQL Injection, XSS ê³µê²© ì™„ì „ ë¬´íš¨í™”.', services: ['AWS WAF', 'GCP Cloud Armor'] },
      { id: 'iam', name: 'IAM', icon: 'ğŸ”‘', category: 'security', cost: 2, hp: 40, attack: 0,
        desc: 'Identity and Access Management. ëˆ„ê°€ ë¬´ì—‡ì„ í•  ìˆ˜ ìˆëŠ”ì§€ ì œì–´. ìµœì†Œ ê¶Œí•œ ì›ì¹™!',
        effect: 'ì ì˜ ê¶Œí•œ ìƒìŠ¹ ê³µê²© ë¬´íš¨í™”.', services: ['AWS IAM', 'GCP IAM', 'Azure AD'] },
      { id: 'ssl', name: 'SSL/TLS', icon: 'ğŸ”', category: 'security', cost: 1, hp: 20, attack: 0,
        desc: 'HTTPSì˜ í•µì‹¬. ë°ì´í„° ì•”í˜¸í™”ë¡œ ë„ì²­ ë°©ì§€. ì´ˆë¡ ìë¬¼ì‡ ì˜ ì •ì²´.',
        effect: 'ëª¨ë“  ì•„êµ°ì´ ë°›ëŠ” ë°ë¯¸ì§€ -5.', services: ['AWS ACM', "Let's Encrypt"] },
      { id: 'kms', name: 'KMS', icon: 'ğŸ—ï¸', category: 'security', cost: 2, hp: 30, attack: 0,
        desc: 'Key Management Service. ì•”í˜¸í™” í‚¤ ê´€ë¦¬. ë°ì´í„° ë³´í˜¸ì˜ í•µì‹¬.',
        effect: 'ë°ì´í„° ìœ ì¶œ ê³µê²© ë°ë¯¸ì§€ 50% ê°ì†Œ.', services: ['AWS KMS', 'GCP Cloud KMS'] },
      { id: 'cicd', name: 'CI/CD', icon: 'ğŸ”„', category: 'devops', cost: 2, hp: 40, attack: 15,
        desc: 'ì§€ì†ì  í†µí•©/ë°°í¬. ì½”ë“œ í‘¸ì‹œ â†’ ìë™ í…ŒìŠ¤íŠ¸ â†’ ìë™ ë°°í¬. DevOpsì˜ ê½ƒ.',
        effect: 'ë§¤í„´ ì¹´ë“œ 1ì¥ ì¶”ê°€ ë“œë¡œìš°.', services: ['GitHub Actions', 'GitLab CI', 'Jenkins'] },
      { id: 'terraform', name: 'Terraform', icon: 'ğŸ—ï¸', category: 'devops', cost: 3, hp: 50, attack: 20,
        desc: 'Infrastructure as Code. ì½”ë“œë¡œ ì¸í”„ë¼ ê´€ë¦¬. ì¬í˜„ ê°€ëŠ¥í•œ í™˜ê²½ êµ¬ì¶•.',
        effect: 'íŒŒê´´ ì‹œ ê°™ì€ ì¹´ë“œ 1ì¥ì„ í•¸ë“œì— ì¶”ê°€.', services: ['Terraform', 'Pulumi', 'AWS CDK'] },
      { id: 'docker', name: 'Docker', icon: 'ğŸ³', category: 'devops', cost: 1, hp: 30, attack: 10,
        desc: 'ì»¨í…Œì´ë„ˆì˜ ì‹œì‘. ì–´ë””ì„œë“  ë™ì¼í•˜ê²Œ ì‹¤í–‰. "ë‚´ ì»´ì—ì„œëŠ” ë˜ëŠ”ë°?"ì˜ í•´ê²°ì‚¬.',
        effect: 'ë‚®ì€ ì½”ìŠ¤íŠ¸ë¡œ ë¹ ë¥¸ ë°°ì¹˜. K8sì™€ í•¨ê»˜ ìˆìœ¼ë©´ ê³µê²©ë ¥ +10.', services: ['Docker', 'Podman'] },
      { id: 'prometheus', name: 'Prometheus', icon: 'ğŸ“ˆ', category: 'monitoring', cost: 2, hp: 40, attack: 0,
        desc: 'ë©”íŠ¸ë¦­ ìˆ˜ì§‘ì˜ í‘œì¤€. ì‹œê³„ì—´ ë°ì´í„°ë² ì´ìŠ¤. Grafanaì™€ ì°°ë–¡ê¶í•©.',
        effect: 'ìƒëŒ€ì˜ ë‹¤ìŒ ê³µê²©ì„ ë¯¸ë¦¬ í™•ì¸.', services: ['Prometheus', 'Datadog', 'New Relic'] },
      { id: 'cloudwatch', name: 'CloudWatch', icon: 'ğŸ‘ï¸', category: 'monitoring', cost: 2, hp: 35, attack: 5,
        desc: 'AWS ëª¨ë‹ˆí„°ë§ ì„œë¹„ìŠ¤. ë¡œê·¸, ë©”íŠ¸ë¦­, ì•ŒëŒ. ì´ìƒ ê°ì§€ì˜ ëˆˆ.',
        effect: 'ì ì˜ ìŠ¤í…”ìŠ¤ ê³µê²© ë¬´íš¨í™”.', services: ['AWS CloudWatch', 'GCP Cloud Monitoring'] },
      { id: 'ddos', name: 'DDoS', icon: 'ğŸ’¥', category: 'attack', cost: 4, hp: 0, attack: 50,
        desc: 'ë¶„ì‚° ì„œë¹„ìŠ¤ ê±°ë¶€ ê³µê²©. ëŒ€ëŸ‰ì˜ íŠ¸ë˜í”½ìœ¼ë¡œ ì„œë²„ ë§ˆë¹„. ê°€ì¥ í”í•œ ê³µê²©.',
        effect: 'ì¦‰ì‹œ ì‚¬ìš©. ìƒëŒ€ ì„œë²„ì— 50 ë°ë¯¸ì§€.', services: ['ê³µê²© ì¹´ë“œ'] },
      { id: 'sqli', name: 'SQL Injection', icon: 'ğŸ’‰', category: 'attack', cost: 3, hp: 0, attack: 80,
        desc: "ì•…ì˜ì  SQL ì¿¼ë¦¬ ì‚½ì…. DB íƒˆì·¨ì˜ ê³ ì „. Bobby Tablesì˜ ì „ì„¤.",
        effect: 'WAFê°€ ì—†ìœ¼ë©´ 80 ë°ë¯¸ì§€. WAF ìˆìœ¼ë©´ ë¬´íš¨.', services: ['ê³µê²© ì¹´ë“œ'] },
      { id: 'mitm', name: 'MITM', icon: 'ğŸ‘¤', category: 'attack', cost: 2, hp: 0, attack: 40,
        desc: 'Man in the Middle. ì¤‘ê°„ì ê³µê²©. í†µì‹  ë„ì²­ ë° ë³€ì¡°.',
        effect: 'SSLì´ ì—†ìœ¼ë©´ 40 ë°ë¯¸ì§€. SSL ìˆìœ¼ë©´ ë¬´íš¨.', services: ['ê³µê²© ì¹´ë“œ'] },
      // === CS ìë£Œêµ¬ì¡° ë± ===
      { id: 'array', name: 'Array', icon: 'ğŸ“¦', category: 'linear', cost: 1, hp: 40, attack: 15, deck: 'datastructure',
        desc: 'ì—°ì†ëœ ë©”ëª¨ë¦¬ ê³µê°„. O(1) ì ‘ê·¼ì˜ ê¸°ë³¸. ì¸ë±ìŠ¤ë§Œ ì•Œë©´ ë°”ë¡œ ì°¾ëŠ”ë‹¤.',
        effect: 'ë‚®ì€ ì½”ìŠ¤íŠ¸ë¡œ ë¹ ë¥¸ ë°°ì¹˜.', services: ['ê¸°ë³¸ ìë£Œêµ¬ì¡°'] },
      { id: 'linkedlist', name: 'LinkedList', icon: 'ğŸ”—', category: 'linear', cost: 2, hp: 50, attack: 20, deck: 'datastructure',
        desc: 'ë…¸ë“œì™€ í¬ì¸í„°ì˜ ì—°ê²°. ì‚½ì…/ì‚­ì œ O(1). ë©”ëª¨ë¦¬ ìœ ì—°í•˜ê²Œ ì‚¬ìš©.',
        effect: 'íŒŒê´´ ì‹œ ë‹¤ìŒ ë…¸ë“œ(ì¹´ë“œ)ì—ê²Œ ê³µê²©ë ¥ +10 ë¶€ì—¬.', services: ['ê¸°ë³¸ ìë£Œêµ¬ì¡°'] },
      { id: 'hashtable', name: 'HashTable', icon: '#ï¸âƒ£', category: 'hash', cost: 3, hp: 60, attack: 30, deck: 'datastructure',
        desc: 'Key-Valueì˜ ì™•. í‰ê·  O(1) ê²€ìƒ‰. í•´ì‹œ ì¶©ëŒë§Œ ì¡°ì‹¬í•˜ë©´ ìµœê°•.',
        effect: 'í•„ë“œì— ìˆìœ¼ë©´ ì¹´ë“œ ê²€ìƒ‰(ë“œë¡œìš°) ì‹œ ì›í•˜ëŠ” ì¹´ë“œ ì„ íƒ ê°€ëŠ¥.', services: ['Dictionary', 'Map'] },
      { id: 'binarytree', name: 'BinaryTree', icon: 'ğŸŒ³', category: 'tree', cost: 3, hp: 70, attack: 25, deck: 'datastructure',
        desc: 'ìµœëŒ€ 2ê°œì˜ ìì‹ ë…¸ë“œ. íƒìƒ‰, ì •ë ¬, ìš°ì„ ìˆœìœ„ íì˜ ê¸°ë°˜.',
        effect: 'ë°°ì¹˜ ì‹œ ì¢Œìš° ì¹´ë“œì— HP +15 ë¶€ì—¬.', services: ['BST', 'Heap'] },
      { id: 'stack', name: 'Stack', icon: 'ğŸ“š', category: 'linear', cost: 1, hp: 30, attack: 20, deck: 'datastructure',
        desc: 'LIFO - ë§ˆì§€ë§‰ì— ë„£ì€ ê²Œ ë¨¼ì € ë‚˜ì˜¨ë‹¤. í•¨ìˆ˜ í˜¸ì¶œì˜ ë¹„ë°€.',
        effect: 'íŒŒê´´ ì‹œ ë§ˆì§€ë§‰ì— ì‚¬ìš©í•œ ì¹´ë“œ 1ì¥ í•¸ë“œë¡œ ë³µê·€.', services: ['Call Stack'] },
      { id: 'queue', name: 'Queue', icon: 'ğŸš¶', category: 'linear', cost: 1, hp: 35, attack: 15, deck: 'datastructure',
        desc: 'FIFO - ë¨¼ì € ë„£ì€ ê²Œ ë¨¼ì € ë‚˜ì˜¨ë‹¤. ì¤„ ì„œê¸°ì˜ ì •ì„.',
        effect: 'ë§¤í„´ ì‹œì‘ ì‹œ ì¹´ë“œ 1ì¥ ìë™ ë“œë¡œìš°.', services: ['BFS', 'Task Queue'] },
      { id: 'graph', name: 'Graph', icon: 'ğŸ•¸ï¸', category: 'graph', cost: 4, hp: 80, attack: 35, deck: 'datastructure',
        desc: 'ì •ì ê³¼ ê°„ì„ ì˜ ë„¤íŠ¸ì›Œí¬. SNS, ì§€ë„, ì¶”ì²œ ì‹œìŠ¤í…œì˜ í•µì‹¬.',
        effect: 'ëª¨ë“  ì•„êµ° ì¹´ë“œì™€ ì—°ê²° - í•˜ë‚˜ê°€ ê³µê²©ë°›ìœ¼ë©´ ë°ë¯¸ì§€ ë¶„ì‚°.', services: ['Neo4j', 'Network'] },
      // === CS ìš´ì˜ì²´ì œ ë± ===
      { id: 'process', name: 'Process', icon: 'âš™ï¸', category: 'process', cost: 2, hp: 50, attack: 20, deck: 'os',
        desc: 'ì‹¤í–‰ ì¤‘ì¸ í”„ë¡œê·¸ë¨. ë…ë¦½ëœ ë©”ëª¨ë¦¬ ê³µê°„. ë¬´ê²ì§€ë§Œ ì•ˆì „.',
        effect: 'ë…ë¦½ì  - ë‹¤ë¥¸ ì¹´ë“œ íŒŒê´´ì— ì˜í–¥ ì•ˆ ë°›ìŒ.', services: ['PID', 'PCB'] },
      { id: 'thread', name: 'Thread', icon: 'ğŸ§µ', category: 'process', cost: 1, hp: 25, attack: 25, deck: 'os',
        desc: 'í”„ë¡œì„¸ìŠ¤ ë‚´ ì‹¤í–‰ ë‹¨ìœ„. ë©”ëª¨ë¦¬ ê³µìœ ë¡œ ê°€ë³ê³  ë¹ ë¦„.',
        effect: 'Processì™€ í•¨ê»˜ ìˆìœ¼ë©´ ê³µê²©ë ¥ 2ë°°.', services: ['Multithreading'] },
      { id: 'mutex', name: 'Mutex', icon: 'ğŸ”’', category: 'sync', cost: 2, hp: 40, attack: 0, deck: 'os',
        desc: 'ìƒí˜¸ ë°°ì œ. í•œ ë²ˆì— í•˜ë‚˜ë§Œ ì ‘ê·¼. ë™ì‹œì„±ì˜ ìˆ˜í˜¸ì.',
        effect: 'ì ì˜ ë™ì‹œ ê³µê²©(2íšŒ ì´ìƒ) ë§‰ìŒ.', services: ['Lock', 'Semaphore'] },
      { id: 'scheduler', name: 'Scheduler', icon: 'ğŸ“…', category: 'process', cost: 3, hp: 45, attack: 15, deck: 'os',
        desc: 'CPU ì‹œê°„ ë¶„ë°°ì˜ ì‹¬íŒ. FCFS, SJF, Round Robin.',
        effect: 'ì•„êµ° ì¹´ë“œ ê³µê²© ìˆœì„œ ìµœì í™” - ë°ë¯¸ì§€ +20%.', services: ['CPU Scheduler'] },
      { id: 'memory', name: 'Memory', icon: 'ğŸ§ ', category: 'memory', cost: 3, hp: 100, attack: 10, deck: 'os',
        desc: 'RAM - íœ˜ë°œì„± ì €ì¥ì†Œ. ë¹ ë¥¸ ì ‘ê·¼, í•œì •ëœ ìš©ëŸ‰.',
        effect: 'í•¸ë“œ ìµœëŒ€ ì¥ìˆ˜ +2.', services: ['RAM', 'Virtual Memory'] },
      { id: 'filesystem', name: 'FileSystem', icon: 'ğŸ“', category: 'system', cost: 2, hp: 60, attack: 5, deck: 'os',
        desc: 'íŒŒì¼ ì €ì¥ê³¼ ê´€ë¦¬. inode, ë””ë ‰í† ë¦¬, ê¶Œí•œì˜ ì„¸ê³„.',
        effect: 'íŒŒê´´ëœ ì¹´ë“œ 1ì¥ì„ ë±ìœ¼ë¡œ ë³µêµ¬.', services: ['ext4', 'NTFS'] },
      // === CS ì•Œê³ ë¦¬ì¦˜ ë± ===
      { id: 'quicksort', name: 'QuickSort', icon: 'âš¡', category: 'sort', cost: 3, hp: 50, attack: 40, deck: 'algorithm',
        desc: 'ë¶„í•  ì •ë³µì˜ ëŒ€í‘œ. í‰ê·  O(n log n). í”¼ë²— ì„ íƒì´ í•µì‹¬.',
        effect: 'ì  ì¹´ë“œ ì¤‘ HP ê°€ì¥ ë‚®ì€ ê²ƒ ìš°ì„  ê³µê²©.', services: ['ì •ë ¬ ì•Œê³ ë¦¬ì¦˜'] },
      { id: 'bfs', name: 'BFS', icon: 'ğŸŒŠ', category: 'search', cost: 2, hp: 40, attack: 25, deck: 'algorithm',
        desc: 'ë„ˆë¹„ ìš°ì„  íƒìƒ‰. ë ˆë²¨ ë‹¨ìœ„ë¡œ íƒìƒ‰. ìµœë‹¨ ê²½ë¡œì˜ ê¸°ë³¸.',
        effect: 'ëª¨ë“  ì  ì¹´ë“œì— 10 ë°ë¯¸ì§€ (ê´‘ì—­).', services: ['ê·¸ë˜í”„ íƒìƒ‰'] },
      { id: 'dfs', name: 'DFS', icon: 'ğŸŠ', category: 'search', cost: 2, hp: 35, attack: 35, deck: 'algorithm',
        desc: 'ê¹Šì´ ìš°ì„  íƒìƒ‰. ëê¹Œì§€ íŒŒê³ ë“ ë‹¤. ë°±íŠ¸ë˜í‚¹ì˜ ì¹œêµ¬.',
        effect: 'ì  1ëª…ì—ê²Œ ì§‘ì¤‘ ê³µê²© (ë°ë¯¸ì§€ 1.5ë°°).', services: ['ê·¸ë˜í”„ íƒìƒ‰'] },
      { id: 'dp', name: 'Dynamic Programming', icon: 'ğŸ“Š', category: 'dp', cost: 4, hp: 60, attack: 30, deck: 'algorithm',
        desc: 'ë©”ëª¨ì´ì œì´ì…˜ì˜ í˜. ì¤‘ë³µ ê³„ì‚° ì œê±°. ìµœì  ë¶€ë¶„ êµ¬ì¡°.',
        effect: 'ì´ì „ì— ì‚¬ìš©í•œ ì¹´ë“œ íš¨ê³¼ ì¬ì‚¬ìš© ê°€ëŠ¥.', services: ['ìµœì í™”'] },
      { id: 'greedy', name: 'Greedy', icon: 'ğŸ¤‘', category: 'technique', cost: 1, hp: 20, attack: 30, deck: 'algorithm',
        desc: 'ë§¤ ìˆœê°„ ìµœì„ ì˜ ì„ íƒ. ë¹ ë¥´ì§€ë§Œ í•­ìƒ ìµœì ì€ ì•„ë‹˜.',
        effect: 'ì¦‰ì‹œ ê³µê²© ê°€ëŠ¥. ë‹¨, ë‹¤ìŒ í„´ ê³µê²© ë¶ˆê°€.', services: ['íƒìš• ì•Œê³ ë¦¬ì¦˜'] },
      { id: 'dijkstra', name: 'Dijkstra', icon: 'ğŸ—ºï¸', category: 'search', cost: 3, hp: 55, attack: 25, deck: 'algorithm',
        desc: 'ìµœë‹¨ ê²½ë¡œì˜ ì „ì„¤. ìŒìˆ˜ ê°€ì¤‘ì¹˜ë§Œ ì•„ë‹ˆë©´ OK.',
        effect: 'ê°€ì¥ ì•½í•œ ì ì„ ì°¾ì•„ ìë™ ê³µê²©.', services: ['ìµœë‹¨ ê²½ë¡œ'] },
      // === ìë£Œêµ¬ì¡° ì¶”ê°€ ì¹´ë“œ ===
      { id: 'heap', name: 'Heap', icon: 'â›°ï¸', category: 'tree', cost: 3, hp: 80, attack: 20, deck: 'datastructure',
        desc: 'ì™„ì „ ì´ì§„ íŠ¸ë¦¬ ê¸°ë°˜ ìš°ì„ ìˆœìœ„ í. ìµœëŒ€/ìµœì†Œê°’ O(1) ì ‘ê·¼.',
        effect: 'ë§¤í„´ ê°€ì¥ ê°•í•œ ì  ì¹´ë“œë¥¼ ìš°ì„  ê³µê²©.', services: ['Priority Queue'] },
      { id: 'trie', name: 'Trie', icon: 'ğŸ”¤', category: 'tree', cost: 2, hp: 45, attack: 15, deck: 'datastructure',
        desc: 'ë¬¸ìì—´ ê²€ìƒ‰ì˜ ë‹¬ì¸. ìë™ì™„ì„±, ì‚¬ì „ êµ¬í˜„ì˜ í•µì‹¬.',
        effect: 'í•„ë“œì— ìˆìœ¼ë©´ ì›í•˜ëŠ” ì¹´ë“œ ê²€ìƒ‰ ê°€ëŠ¥.', services: ['Prefix Tree'] },
      { id: 'set', name: 'Set', icon: 'ğŸ¯', category: 'hash', cost: 1, hp: 35, attack: 18, deck: 'datastructure',
        desc: 'ì¤‘ë³µ ì—†ëŠ” ì§‘í•©. ì¡´ì¬ ì—¬ë¶€ O(1) í™•ì¸.',
        effect: 'ê°™ì€ ì¹´ë“œ ì¤‘ë³µ ë°°ì¹˜ ì‹œ ê³µê²©ë ¥ +15.', services: ['HashSet'] },
      { id: 'deque', name: 'Deque', icon: 'â†”ï¸', category: 'linear', cost: 2, hp: 40, attack: 22, deck: 'datastructure',
        desc: 'ì–‘ë°©í–¥ í. ì•ë’¤ ëª¨ë‘ O(1) ì‚½ì…/ì‚­ì œ.',
        effect: 'ë°°ì¹˜ ìœ„ì¹˜ ììœ ë¡­ê²Œ ì„ íƒ ê°€ëŠ¥.', services: ['Double-ended Queue'] },
      { id: 'rbtree', name: 'Red-Black Tree', icon: 'ğŸ”´âš«', category: 'tree', cost: 4, hp: 90, attack: 28, deck: 'datastructure',
        desc: 'ìê°€ ê· í˜• ì´ì§„ íƒìƒ‰ íŠ¸ë¦¬. ì‚½ì…/ì‚­ì œ í›„ì—ë„ O(log n) ë³´ì¥.',
        effect: 'ë°›ëŠ” ë°ë¯¸ì§€ 20% ê°ì†Œ (ê· í˜• ìœ ì§€).', services: ['TreeMap', 'TreeSet'] },
      { id: 'pqueue', name: 'PriorityQueue', icon: 'ğŸ†', category: 'tree', cost: 2, hp: 35, attack: 30, deck: 'datastructure',
        desc: 'ìš°ì„ ìˆœìœ„ëŒ€ë¡œ ì²˜ë¦¬. ì‘ì—… ìŠ¤ì¼€ì¤„ë§ì˜ í•µì‹¬.',
        effect: 'ê³µê²© ì‹œ ê°€ì¥ ìœ„í—˜í•œ ì  ìš°ì„  íƒ€ê²Ÿ.', services: ['Heap ê¸°ë°˜'] },
      { id: 'bloom', name: 'BloomFilter', icon: 'ğŸŒ¸', category: 'hash', cost: 1, hp: 25, attack: 10, deck: 'datastructure',
        desc: 'í™•ë¥ ì  ìë£Œêµ¬ì¡°. ìˆì„ ìˆ˜ë„ ìˆê³  ì—†ì„ ìˆ˜ë„ ìˆê³ ... ê±°ì§“ ì–‘ì„± ì£¼ì˜!',
        effect: '30% í™•ë¥ ë¡œ ì  ê³µê²© íšŒí”¼.', services: ['ìºì‹œ', 'ìŠ¤íŒ¸ í•„í„°'] },
      // === ìš´ì˜ì²´ì œ ì¶”ê°€ ì¹´ë“œ ===
      { id: 'kernel', name: 'Kernel', icon: 'ğŸ›ï¸', category: 'system', cost: 5, hp: 120, attack: 25, deck: 'os',
        desc: 'OSì˜ í•µì‹¬. í•˜ë“œì›¨ì–´ì™€ ì†Œí”„íŠ¸ì›¨ì–´ ì‚¬ì´ì˜ ì¤‘ì¬ì.',
        effect: 'ëª¨ë“  OS ì¹´ë“œ ê³µê²©ë ¥ +10.', services: ['Linux', 'Windows NT'] },
      { id: 'interrupt', name: 'Interrupt', icon: 'âš¡', category: 'process', cost: 1, hp: 20, attack: 35, deck: 'os',
        desc: 'CPUì•¼ ì ê¹! ê¸‰í•œ ì¼ì´ ìƒê²¼ì–´. í•˜ë˜ ì¼ ë©ˆì¶”ê³  ì´ê²ƒë¶€í„°.',
        effect: 'ì  í„´ì— ì¦‰ì‹œ ë°˜ê²© ê°€ëŠ¥.', services: ['IRQ', 'ISR'] },
      { id: 'pagetable', name: 'PageTable', icon: 'ğŸ“‘', category: 'memory', cost: 2, hp: 50, attack: 10, deck: 'os',
        desc: 'ê°€ìƒ ì£¼ì†Œ â†’ ë¬¼ë¦¬ ì£¼ì†Œ ë³€í™˜ì˜ ë¹„ë°€. ë©”ëª¨ë¦¬ ë³´í˜¸ì˜ í•µì‹¬.',
        effect: 'ì•„êµ° ì¹´ë“œê°€ ë°›ëŠ” ë°ë¯¸ì§€ -10.', services: ['MMU', 'TLB'] },
      { id: 'cache', name: 'Cache', icon: 'ğŸ’¨', category: 'memory', cost: 2, hp: 30, attack: 25, deck: 'os',
        desc: 'ìì£¼ ì“°ëŠ” ê±´ ê°€ê¹Œì´! L1, L2, L3ì˜ ê³„ì¸µ êµ¬ì¡°.',
        effect: 'ê°™ì€ ì¹´ë“œ ì—°ì† ì‚¬ìš© ì‹œ ì½”ìŠ¤íŠ¸ -1.', services: ['CPU Cache'] },
      { id: 'deadlock', name: 'Deadlock', icon: 'ğŸ’€', category: 'sync', cost: 3, hp: 40, attack: 0, deck: 'os',
        desc: 'ì„œë¡œ ê¸°ë‹¤ë¦¬ë‹¤ ì˜ì›íˆ ë©ˆì¶¤. ìƒí˜¸ë°°ì œ, ì ìœ ëŒ€ê¸°, ë¹„ì„ ì , ìˆœí™˜ëŒ€ê¸°.',
        effect: 'ì  ì¹´ë“œ 1ì¥ì„ 2í„´ê°„ í–‰ë™ë¶ˆëŠ¥.', services: ['êµì°©ìƒíƒœ'] },
      { id: 'semaphore', name: 'Semaphore', icon: 'ğŸš¦', category: 'sync', cost: 2, hp: 45, attack: 12, deck: 'os',
        desc: 'ì‹ í˜¸ë“±ì²˜ëŸ¼ ìì› ì ‘ê·¼ ì œì–´. Mutexì˜ ì¼ë°˜í™” ë²„ì „.',
        effect: 'ì•„êµ° ì¹´ë“œ ë™ì‹œ ê³µê²© ì‹œ ë°ë¯¸ì§€ +20%.', services: ['ë™ê¸°í™”'] },
      { id: 'shell', name: 'Shell', icon: 'ğŸ’»', category: 'system', cost: 1, hp: 30, attack: 15, deck: 'os',
        desc: 'ì‚¬ìš©ìì™€ ì»¤ë„ ì‚¬ì´ì˜ ì¸í„°í˜ì´ìŠ¤. bash, zsh, PowerShell.',
        effect: 'ë°°ì¹˜ ì‹œ ì¹´ë“œ 1ì¥ ë“œë¡œìš°.', services: ['CLI', 'Terminal'] },
      { id: 'vmemory', name: 'Virtual Memory', icon: 'ğŸŒ€', category: 'memory', cost: 4, hp: 100, attack: 15, deck: 'os',
        desc: 'ì‹¤ì œë³´ë‹¤ í° ë©”ëª¨ë¦¬ì²˜ëŸ¼! ìŠ¤ì™‘ê³¼ í˜ì´ì§•ì˜ ë§ˆë²•.',
        effect: 'í•¸ë“œ ìµœëŒ€ +3, ë± ì†Œì§„ ì‹œ ë²„ë¦° ì¹´ë“œ ì¬í™œìš©.', services: ['Swap', 'Paging'] },
      // === ì•Œê³ ë¦¬ì¦˜ ì¶”ê°€ ì¹´ë“œ ===
      { id: 'bsearch', name: 'Binary Search', icon: 'ğŸ”', category: 'search', cost: 1, hp: 25, attack: 28, deck: 'algorithm',
        desc: 'ë°˜ì”© ë‚˜ëˆ ì„œ ì°¾ê¸°. ì •ë ¬ëœ ë°ì´í„°ì—ì„œ O(log n).',
        effect: 'ì  ì¹´ë“œ ì¤‘ íŠ¹ì • HP ì´í•˜ë§Œ ê³µê²© ê°€ëŠ¥ (ì •ë°€ íƒ€ê²©).', services: ['ì´ë¶„ íƒìƒ‰'] },
      { id: 'msort', name: 'MergeSort', icon: 'ğŸ”€', category: 'sort', cost: 3, hp: 65, attack: 30, deck: 'algorithm',
        desc: 'ë¶„í•  ì •ë³µ ì •ë ¬. ì•ˆì • ì •ë ¬, ìµœì•…ì—ë„ O(n log n).',
        effect: '2ì¥ ì´ìƒ ë°°ì¹˜ ì‹œ ê³µê²©ë ¥ í•©ì‚°.', services: ['ë¶„í•  ì •ë³µ'] },
      { id: 'astar', name: 'A* Algorithm', icon: 'â­', category: 'search', cost: 4, hp: 50, attack: 35, deck: 'algorithm',
        desc: 'íœ´ë¦¬ìŠ¤í‹± + ë‹¤ìµìŠ¤íŠ¸ë¼. ê²Œì„ AI ê¸¸ì°¾ê¸°ì˜ ì •ì„.',
        effect: 'ì  ì„œë²„ ì§ì ‘ ê³µê²© ì‹œ ë°ë¯¸ì§€ 1.5ë°°.', services: ['ê²½ë¡œ íƒìƒ‰'] },
      { id: 'backtrack', name: 'Backtracking', icon: 'â†©ï¸', category: 'dp', cost: 2, hp: 40, attack: 20, deck: 'algorithm',
        desc: 'ë§‰ë‹¤ë¥¸ ê¸¸ì´ë©´ ë˜ëŒì•„ê°€! N-Queen, ìŠ¤ë„ì¿ ì˜ í•´ë²•.',
        effect: 'íŒŒê´´ ì‹œ í•¸ë“œë¡œ ë³µê·€ (1íšŒ).', services: ['ì™„ì „ íƒìƒ‰'] },
      { id: 'recursion', name: 'Recursion', icon: 'ğŸ”', category: 'dp', cost: 2, hp: 35, attack: 25, deck: 'algorithm',
        desc: 'ìê¸° ìì‹ ì„ í˜¸ì¶œ. ê¸°ì € ì¡°ê±´ ì—†ìœ¼ë©´ ìŠ¤íƒ ì˜¤ë²„í”Œë¡œìš°!',
        effect: 'ê³µê²© ì‹œ 30% í™•ë¥ ë¡œ í•œ ë²ˆ ë” ê³µê²©.', services: ['ì¬ê·€ í˜¸ì¶œ'] },
      { id: 'twoptr', name: 'Two Pointers', icon: 'ğŸ‘†ğŸ‘†', category: 'technique', cost: 1, hp: 30, attack: 22, deck: 'algorithm',
        desc: 'ì–‘ìª½ì—ì„œ ì¢í˜€ì˜¤ê¸°. ì •ë ¬ëœ ë°°ì—´ íƒìƒ‰ì˜ ê¿€íŒ.',
        effect: 'ì–‘ ì˜† ì¹´ë“œì™€ í•¨ê»˜ ê³µê²© ì‹œ ë°ë¯¸ì§€ +30%.', services: ['íˆ¬ í¬ì¸í„°'] },
      { id: 'slidingwin', name: 'Sliding Window', icon: 'ğŸªŸ', category: 'technique', cost: 2, hp: 45, attack: 18, deck: 'algorithm',
        desc: 'ì°½ë¬¸ì„ ë°€ë©´ì„œ íƒìƒ‰. ë¶€ë¶„ ë°°ì—´/ë¬¸ìì—´ ë¬¸ì œì˜ í•µì‹¬.',
        effect: 'ì—°ì† 3í„´ í•„ë“œ ìœ ì§€ ì‹œ ê³µê²©ë ¥ 2ë°°.', services: ['êµ¬ê°„ íƒìƒ‰'] },
      { id: 'unionfind', name: 'Union-Find', icon: 'ğŸ¤', category: 'technique', cost: 3, hp: 70, attack: 20, deck: 'algorithm',
        desc: 'ì„œë¡œì†Œ ì§‘í•©. ëˆ„ê°€ ê°™ì€ í¸ì¸ì§€ ë¹ ë¥´ê²Œ í™•ì¸.',
        effect: 'ê°™ì€ ë± ì¹´ë“œë¼ë¦¬ ë°ë¯¸ì§€ ê³µìœ  (ë¶„ì‚°).', services: ['Disjoint Set'] },
    ];

    // === ë± ì‹œìŠ¤í…œ ===
    const deckDefinitions = {
      infra: {
        name: 'ğŸ–¥ï¸ ì¸í”„ë¼',
        desc: 'í´ë¼ìš°ë“œ ì„œë¹„ìŠ¤ ì¹´ë“œë¡œ ì•ˆì •ì ì¸ ì„œë²„ êµ¬ì¶•',
        color: '#00d9ff',
        categories: ['computing', 'storage', 'database', 'network', 'security', 'devops', 'monitoring']
      },
      datastructure: {
        name: 'ğŸ“Š ìë£Œêµ¬ì¡°',
        desc: 'íš¨ìœ¨ì ì¸ ë°ì´í„° ê´€ë¦¬ë¡œ ìŠ¹ë¦¬',
        color: '#ff6b6b',
        categories: ['linear', 'tree', 'hash', 'graph']
      },
      os: {
        name: 'âš™ï¸ ìš´ì˜ì²´ì œ',
        desc: 'í”„ë¡œì„¸ìŠ¤ì™€ ë©”ëª¨ë¦¬ë¡œ ì‹œìŠ¤í…œ ì¥ì•…',
        color: '#4ecdc4',
        categories: ['process', 'memory', 'sync', 'system']
      },
      algorithm: {
        name: 'ğŸ§® ì•Œê³ ë¦¬ì¦˜',
        desc: 'ìµœì ì˜ ì „ëµìœ¼ë¡œ ì ì„ ì œì••',
        color: '#ffe66d',
        categories: ['sort', 'search', 'dp', 'technique']
      }
    };

    let selectedDeck = 'infra'; // ê¸°ë³¸ ë±

    function selectDeck(deckId) {
      selectedDeck = deckId;
      // UI ì—…ë°ì´íŠ¸
      document.querySelectorAll('.deck-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.deck === deckId);
      });
      // ë± ì„¤ëª… ì—…ë°ì´íŠ¸
      const deckDef = deckDefinitions[deckId];
      document.getElementById('deckDesc').textContent = deckDef.desc;
    }

    // ê²Œì„ ìƒíƒœ
    let game = {
      started: false,
      turn: 'player',
      mana: 1,
      maxMana: 1,
      turnCount: 1,
      player: { hp: 100, maxHp: 100, field: [], hand: [], deck: [] },
      enemy: { hp: 100, maxHp: 100, field: [], mana: 0 },
      selectedCard: null,
      selectedIndex: null,
      stats: { wins: 0, losses: 0, fastestWin: 999 },
      combo: 0,
      nextEnemyAttack: null
    };

    // ë¡œì»¬ ìŠ¤í† ë¦¬ì§€ì—ì„œ í†µê³„ ë¡œë“œ
    try {
      const saved = localStorage.getItem('serverDefenseStats');
      if (saved) game.stats = JSON.parse(saved);
    } catch(e) {}

    function saveStats() {
      try { localStorage.setItem('serverDefenseStats', JSON.stringify(game.stats)); } catch(e) {}
    }

    // ì  ì¹´ë“œ (ë‚œì´ë„ë³„)
    const enemyCards = {
      easy: [
        { id: 'bot1', name: 'ìŠ¤íŒ¸ë´‡', icon: 'ğŸ¤–', hp: 30, attack: 10 },
        { id: 'bot2', name: 'í¬ë¡¤ëŸ¬', icon: 'ğŸ•·ï¸', hp: 40, attack: 15 }
      ],
      normal: [
        { id: 'bot1', name: 'ìŠ¤íŒ¸ë´‡', icon: 'ğŸ¤–', hp: 30, attack: 10 },
        { id: 'bot2', name: 'í¬ë¡¤ëŸ¬', icon: 'ğŸ•·ï¸', hp: 40, attack: 15 },
        { id: 'bot3', name: 'ë´‡ë„·', icon: 'ğŸ‘¾', hp: 60, attack: 25 }
      ],
      hard: [
        { id: 'bot2', name: 'í¬ë¡¤ëŸ¬', icon: 'ğŸ•·ï¸', hp: 40, attack: 15 },
        { id: 'bot3', name: 'ë´‡ë„·', icon: 'ğŸ‘¾', hp: 60, attack: 25 },
        { id: 'bot4', name: 'APT', icon: 'ğŸ’€', hp: 80, attack: 35 }
      ]
    };

    // ========== íŠœí† ë¦¬ì–¼ ì‹œìŠ¤í…œ ==========
    const tutorialSteps = [
      {
        title: 'ğŸ® ì„œë²„ ë””íœìŠ¤ì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!',
        text: 'ì¸í”„ë¼ ì¹´ë“œë¥¼ ë°°ì¹˜í•˜ê³  ì ì˜ ê³µê²©ìœ¼ë¡œë¶€í„° ì„œë²„ë¥¼ ì§€í‚¤ì„¸ìš”!<br><br>ìƒëŒ€ ì„œë²„ HPë¥¼ 0ìœ¼ë¡œ ë§Œë“¤ë©´ ìŠ¹ë¦¬!',
        highlight: null
      },
      {
        title: 'ğŸƒ ì¹´ë“œ í™•ì¸í•˜ê¸°',
        text: 'í•¸ë“œì˜ ì¹´ë“œë¥¼ <strong>íƒ­</strong>í•˜ë©´ ìƒì„¸ ì •ë³´ë¥¼ ë³¼ ìˆ˜ ìˆì–´ìš”.<br><br>ê° ì¹´ë“œì˜ íš¨ê³¼ë¥¼ í™•ì¸í•´ë³´ì„¸ìš”!',
        highlight: 'hand',
        arrow: { target: 'hand', direction: 'up' }
      },
      {
        title: 'âš¡ ì¹´ë“œ ë°°ì¹˜í•˜ê¸°',
        text: 'ì¹´ë“œë¥¼ <strong>ë“œë˜ê·¸</strong>í•´ì„œ í•„ë“œì— ë†“ìœ¼ë©´ ë°°ì¹˜ë©ë‹ˆë‹¤.<br><br>ì™¼ìª½ ìƒë‹¨ì˜ ìˆ«ìê°€ í•„ìš”í•œ ë§ˆë‚˜ì˜ˆìš”.',
        highlight: 'hand',
        arrow: { target: 'field', direction: 'down' }
      },
      {
        title: 'â­ï¸ í„´ ì¢…ë£Œ',
        text: 'í•  ì¼ì„ ë‹¤ í–ˆìœ¼ë©´ <strong>í„´ ì¢…ë£Œ</strong> ë²„íŠ¼ì„ ëˆŒëŸ¬ì£¼ì„¸ìš”.<br><br>ë°°ì¹˜í•œ ì¹´ë“œëŠ” ë‹¤ìŒ í„´ë¶€í„° ê³µê²©í•  ìˆ˜ ìˆì–´ìš”!',
        highlight: 'endTurn'
      },
      {
        title: 'âš”ï¸ ê³µê²©í•˜ê¸°',
        text: 'ì´ˆë¡ìƒ‰ í…Œë‘ë¦¬ ì¹´ë“œë¥¼ <strong>ë“œë˜ê·¸</strong>í•´ì„œ ì ì—ê²Œ ê³µê²©!<br><br>ì  ìœ ë‹›ì´ ì—†ìœ¼ë©´ ì„œë²„ë¥¼ ì§ì ‘ ê³µê²©í•  ìˆ˜ ìˆì–´ìš”.',
        highlight: 'field'
      }
    ];

    let tutorialState = {
      active: false,
      step: 0,
      completed: false
    };

    // íŠœí† ë¦¬ì–¼ ì™„ë£Œ ì—¬ë¶€ í™•ì¸
    function checkTutorialCompleted() {
      try {
        return localStorage.getItem('serverDefenseTutorial') === 'completed';
      } catch(e) {
        return false;
      }
    }

    function setTutorialCompleted() {
      try {
        localStorage.setItem('serverDefenseTutorial', 'completed');
      } catch(e) {}
    }

    function startTutorial() {
      tutorialState.active = true;
      tutorialState.step = 0;
      showTutorialStep();
    }

    function showTutorialStep() {
      const step = tutorialSteps[tutorialState.step];
      if (!step) {
        endTutorial();
        return;
      }

      document.getElementById('tutorialStep').textContent = `${tutorialState.step + 1}/${tutorialSteps.length}`;
      document.getElementById('tutorialTitle').textContent = step.title;
      document.getElementById('tutorialText').innerHTML = step.text;
      document.getElementById('tutorialOverlay').classList.add('active');

      // ë§ˆì§€ë§‰ ë‹¨ê³„ë©´ ë²„íŠ¼ í…ìŠ¤íŠ¸ ë³€ê²½
      const nextBtn = document.getElementById('tutorialNext');
      nextBtn.textContent = tutorialState.step === tutorialSteps.length - 1 ? 'ì‹œì‘í•˜ê¸°!' : 'ë‹¤ìŒ';

      // í•˜ì´ë¼ì´íŠ¸ ì ìš©
      clearTutorialHighlights();
      if (step.highlight) {
        applyTutorialHighlight(step.highlight);
      }
    }

    function nextTutorialStep() {
      tutorialState.step++;
      if (tutorialState.step >= tutorialSteps.length) {
        endTutorial();
      } else {
        showTutorialStep();
      }
    }

    function skipTutorial() {
      setTutorialCompleted();
      endTutorial();
    }

    function endTutorial() {
      tutorialState.active = false;
      setTutorialCompleted();
      document.getElementById('tutorialOverlay').classList.remove('active');
      clearTutorialHighlights();
    }

    function applyTutorialHighlight(target) {
      switch(target) {
        case 'hand':
          document.getElementById('playerHand')?.classList.add('tutorial-highlight');
          break;
        case 'field':
          document.getElementById('playerField')?.classList.add('tutorial-highlight');
          break;
        case 'endTurn':
          document.getElementById('endTurnBtn')?.classList.add('tutorial-highlight');
          break;
      }
    }

    function clearTutorialHighlights() {
      document.querySelectorAll('.tutorial-highlight').forEach(el => {
        el.classList.remove('tutorial-highlight');
      });
    }

    // ========== ë„ì›€ë§ ì‹œìŠ¤í…œ ==========
    function toggleHelp() {
      const modal = document.getElementById('helpModal');
      modal.classList.toggle('active');
    }

    function closeHelp(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('helpModal').classList.remove('active');
    }

    function resetTutorial() {
      try {
        localStorage.removeItem('serverDefenseTutorial');
        alert('íŠœí† ë¦¬ì–¼ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ê²Œì„ì„ ì‹œì‘í•˜ë©´ íŠœí† ë¦¬ì–¼ì´ ë‹¤ì‹œ ë‚˜íƒ€ë‚©ë‹ˆë‹¤!');
      } catch(e) {}
    }

    // ========== ë„ê° ê¸°ëŠ¥ ==========
    // ë„ê° í•„í„° ìƒíƒœ
    let currentDeckFilter = 'all';
    let currentCategoryFilter = 'all';

    // ë±ë³„ ì¹´í…Œê³ ë¦¬ ì •ì˜
    const deckCategories = {
      all: ['computing', 'storage', 'database', 'network', 'security', 'devops', 'monitoring', 
            'linear', 'tree', 'hash', 'graph', 'process', 'memory', 'sync', 'system',
            'sort', 'search', 'dp', 'technique', 'attack'],
      infra: ['computing', 'storage', 'database', 'network', 'security', 'devops', 'monitoring', 'attack'],
      datastructure: ['linear', 'tree', 'hash', 'graph'],
      os: ['process', 'memory', 'sync', 'system'],
      algorithm: ['sort', 'search', 'dp', 'technique']
    };

    function updateCategoryFilters(deck) {
      const container = document.getElementById('categoryFilters');
      const categories = deckCategories[deck] || deckCategories.all;
      
      let html = '<button class="filter-btn active" data-filter="all">ì „ì²´</button>';
      categories.forEach(cat => {
        html += `<button class="filter-btn" data-filter="${cat}">${getCategoryName(cat)}</button>`;
      });
      container.innerHTML = html;
      
      // ì´ë²¤íŠ¸ ë°”ì¸ë”©
      container.querySelectorAll('.filter-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          container.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
          currentCategoryFilter = btn.dataset.filter;
          renderCardGrid();
        });
      });
    }

    function renderCardGrid() {
      const grid = document.getElementById('cardGrid');
      
      // ë± í•„í„°
      let cards = allCards;
      if (currentDeckFilter !== 'all') {
        const deckDef = deckDefinitions[currentDeckFilter];
        cards = cards.filter(c => 
          deckDef.categories.includes(c.category) || c.deck === currentDeckFilter
        );
      }
      
      // ì¹´í…Œê³ ë¦¬ í•„í„°
      if (currentCategoryFilter !== 'all') {
        cards = cards.filter(c => c.category === currentCategoryFilter);
      }
      
      grid.innerHTML = cards.map(card => `
        <div class="card-item" onclick="showCardDetail('${card.id}')">
          <div class="icon">${card.icon}</div>
          <div class="name">${card.name}</div>
          <div class="category">${getCategoryName(card.category)}</div>
          <div class="stats">
            <span class="cost">âš¡${card.cost}</span>
            <span class="atk">âš”ï¸${card.attack}</span>
            <span class="hp">â¤ï¸${card.hp}</span>
          </div>
        </div>
      `).join('');
    }

    function getCategoryName(cat) {
      const names = {
        computing: 'ğŸ–¥ï¸ ì»´í“¨íŒ…', storage: 'ğŸ’¾ ìŠ¤í† ë¦¬ì§€', database: 'ğŸ—„ï¸ DB',
        network: 'ğŸŒ ë„¤íŠ¸ì›Œí¬', security: 'ğŸ”’ ë³´ì•ˆ', devops: 'âš™ï¸ DevOps',
        monitoring: 'ğŸ“Š ëª¨ë‹ˆí„°ë§', attack: 'ğŸ’¥ ê³µê²©',
        linear: 'ğŸ“ ì„ í˜•', tree: 'ğŸŒ³ íŠ¸ë¦¬', hash: 'ğŸ”¢ í•´ì‹œ', graph: 'ğŸ•¸ï¸ ê·¸ë˜í”„',
        process: 'âš™ï¸ í”„ë¡œì„¸ìŠ¤', memory: 'ğŸ§  ë©”ëª¨ë¦¬', sync: 'ğŸ”’ ë™ê¸°í™”', system: 'ğŸ’» ì‹œìŠ¤í…œ',
        sort: 'ğŸ”€ ì •ë ¬', search: 'ğŸ” íƒìƒ‰', dp: 'ğŸ“Š DP', technique: 'ğŸ› ï¸ ê¸°ë²•'
      };
      return names[cat] || cat;
    }

    function showCardDetail(cardId) {
      const card = allCards.find(c => c.id === cardId);
      if (!card) return;

      document.getElementById('modalIcon').textContent = card.icon;
      document.getElementById('modalName').textContent = card.name;
      document.getElementById('modalCategory').textContent = getCategoryName(card.category);
      document.getElementById('modalCost').textContent = card.cost;
      document.getElementById('modalHp').textContent = card.hp;
      document.getElementById('modalAtk').textContent = card.attack;
      document.getElementById('modalDesc').textContent = card.desc;
      document.getElementById('modalEffect').textContent = 'ğŸ’¡ ' + card.effect;
      document.getElementById('modalServices').innerHTML = card.services.map(s => 
        `<span class="service-tag">${s}</span>`
      ).join('');

      document.getElementById('modalOverlay').classList.add('active');
    }

    function closeModal(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('modalOverlay').classList.remove('active');
    }

    // ========== ê²Œì„ ê¸°ëŠ¥ ==========
    function startGame(difficulty) {
      const diffSettings = {
        easy: { enemyHp: 100, playerHp: 100, atkMod: 1.0, spawnRate: 0.2, drawRate: 1, doubleAttack: false },
        normal: { enemyHp: 130, playerHp: 80, atkMod: 1.3, spawnRate: 0.35, drawRate: 1, doubleAttack: false },
        hard: { enemyHp: 160, playerHp: 60, atkMod: 1.5, spawnRate: 0.5, drawRate: 0.5, doubleAttack: true }
      };
      const settings = diffSettings[difficulty];

      game = {
        ...game,
        started: true,
        turn: 'player',
        mana: 1,
        maxMana: 1,
        turnCount: 1,
        difficulty,
        settings,
        combo: 0,
        nextEnemyAttack: null,
        player: { hp: settings.playerHp, maxHp: settings.playerHp, field: [], hand: [], deck: [] },
        enemy: { 
          hp: settings.enemyHp,
          maxHp: settings.enemyHp,
          field: [],
          mana: 0
        },
        selectedCard: null,
        selectedIndex: null
      };

      // ë± ìƒì„± (ì„ íƒëœ ë±ì˜ ì¹´í…Œê³ ë¦¬ë§Œ, ê³µê²© ì¹´ë“œ ì œì™¸)
      const deckDef = deckDefinitions[selectedDeck];
      const deckCards = allCards.filter(c => 
        c.category !== 'attack' && 
        (deckDef.categories.includes(c.category) || c.deck === selectedDeck)
      );
      game.player.deck = shuffle([...deckCards, ...deckCards]).slice(0, 20);
      game.currentDeck = selectedDeck;

      // ì´ˆê¸° í•¸ë“œ (ì½”ìŠ¤íŠ¸1 ì¹´ë“œ ìµœì†Œ 1ì¥ ë³´ì¥)
      const cost1Cards = game.player.deck.filter(c => c.cost === 1);
      if (cost1Cards.length > 0) {
        // ì½”ìŠ¤íŠ¸1 ì¹´ë“œ 1ì¥ í™•ì •
        const idx = game.player.deck.findIndex(c => c.cost === 1);
        if (idx !== -1) {
          const [card] = game.player.deck.splice(idx, 1);
          game.player.hand.push({ ...card, uid: Date.now() + Math.random() });
        }
      }
      // ë‚˜ë¨¸ì§€ 3ì¥ ë“œë¡œìš°
      for (let i = game.player.hand.length; i < 4; i++) drawCard();

      // Prometheus íš¨ê³¼: ë‹¤ìŒ ê³µê²© ë¯¸ë¦¬ë³´ê¸°
      prepareNextEnemyAttack();

      document.body.classList.add('game-mode');
      document.getElementById('gameStart').style.display = 'none';
      document.getElementById('battleLog').style.display = 'block';
      updateBattleUI();
      addLog(`ğŸ® ${difficulty.toUpperCase()} ëª¨ë“œ ì‹œì‘!`, 'info');

      // ì²« í”Œë ˆì´ ì‹œ íŠœí† ë¦¬ì–¼ ì‹œì‘
      if (!checkTutorialCompleted()) {
        setTimeout(() => startTutorial(), 500);
      }
    }

    function exitGame() {
      document.body.classList.remove('game-mode');
      document.getElementById('gameStart').style.display = 'block';
      document.getElementById('battleLog').style.display = 'none';
      game.started = false;
    }

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function drawCard() {
      if (game.player.deck.length > 0 && game.player.hand.length < 7) {
        game.player.hand.push({ ...game.player.deck.pop(), uid: Date.now() + Math.random() });
      }
    }

    function selectHandCard(index) {
      const card = game.player.hand[index];
      if (!card) return;

      game.selectedCard = card;
      game.selectedIndex = index;

      document.getElementById('gameCardIcon').textContent = card.icon;
      document.getElementById('gameCardName').textContent = card.name;
      document.getElementById('gameCardCategory').textContent = getCategoryName(card.category);
      document.getElementById('gameCardCost').textContent = card.cost;
      document.getElementById('gameCardHp').textContent = card.hp;
      document.getElementById('gameCardAtk').textContent = card.attack;
      document.getElementById('gameCardDesc').textContent = card.desc;
      document.getElementById('gameCardEffect').textContent = 'ğŸ’¡ ' + card.effect;

      const canPlay = card.cost <= game.mana;
      document.getElementById('gameCardActions').innerHTML = canPlay
        ? `<button class="btn btn-primary" onclick="playSelectedCard()">ë°°ì¹˜</button>
           <button class="btn btn-danger" onclick="closeGameCardModal()">ì·¨ì†Œ</button>`
        : `<button class="btn btn-danger" onclick="closeGameCardModal()">ë§ˆë‚˜ ë¶€ì¡± (${card.cost}í•„ìš”)</button>`;

      document.getElementById('gameCardModal').classList.add('active');
    }

    function closeGameCardModal(e) {
      if (e && e.target !== e.currentTarget) return;
      document.getElementById('gameCardModal').classList.remove('active');
      game.selectedCard = null;
      game.selectedIndex = null;
    }

    function playSelectedCard() {
      if (game.selectedIndex === null) return;
      const card = game.player.hand[game.selectedIndex];
      if (card.cost > game.mana) return;
      if (game.player.field.length >= 6) {
        addLog('âš ï¸ í•„ë“œê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤! (ìµœëŒ€ 6ì¥)', 'info');
        return;
      }

      game.mana -= card.cost;
      const newCard = { ...card, currentHp: card.hp, canAttack: false, bonusAtk: 0 };
      
      // Fargate íŠ¹ìˆ˜ íš¨ê³¼: ë°°ì¹˜ ì¦‰ì‹œ ê³µê²© ê°€ëŠ¥
      if (card.id === 'fargate') {
        newCard.canAttack = true;
        addLog(`ğŸš€ Fargate ì¦‰ì‹œ ë°°ì¹˜ ì™„ë£Œ!`, 'info');
      }

      game.player.field.push(newCard);
      game.player.hand.splice(game.selectedIndex, 1);
      
      // ì‹œë„ˆì§€ íš¨ê³¼ ì ìš©
      applySynergyEffects();
      
      addLog(`${card.icon} ${card.name} ë°°ì¹˜!`, 'info');
      closeGameCardModal();
      updateBattleUI();
    }

    // ì‹œë„ˆì§€ íš¨ê³¼ ê³„ì‚°
    function applySynergyEffects() {
      const field = game.player.field;
      const hasCard = (id) => field.some(c => c.id === id);
      
      field.forEach(card => {
        card.bonusAtk = 0;
        
        // Route 53: ëª¨ë“  ì¹´ë“œ ê³µê²©ë ¥ +5
        if (hasCard('route53') && card.id !== 'route53') {
          card.bonusAtk += 5;
        }
        
        // Lambda + DynamoDB: Lambda ê³µê²©ë ¥ +15
        if (card.id === 'lambda' && hasCard('dynamodb')) {
          card.bonusAtk += 15;
        }
        
        // Docker + K8s: Docker ê³µê²©ë ¥ +10
        if (card.id === 'docker' && hasCard('k8s')) {
          card.bonusAtk += 10;
        }
        
        // EBS + EC2: EC2 HP +30 (í•œ ë²ˆë§Œ)
        if (card.id === 'ec2' && hasCard('ebs') && !card.ebsBoosted) {
          card.currentHp = Math.min(card.hp + 30, card.currentHp + 30);
          card.ebsBoosted = true;
          addLog(`ğŸ’¾ EBS ì—°ê²°! EC2 HP +30`, 'info');
        }
      });
    }

    // ë°ë¯¸ì§€ ê°ì†Œ ê³„ì‚°
    function calculateDamageReduction(baseDmg, target) {
      let dmg = baseDmg;
      const field = game.player.field;
      
      // SSL/TLS: -5
      if (field.some(c => c.id === 'ssl')) dmg -= 5;
      
      // VPC: -5
      if (field.some(c => c.id === 'vpc')) dmg -= 5;
      
      // Redis + DB: DB ì•ì— Redis ìˆìœ¼ë©´ -30%
      if (target && ['rds', 'dynamodb'].includes(target.id)) {
        const redisIdx = field.findIndex(c => c.id === 'redis');
        const targetIdx = field.findIndex(c => c.uid === target.uid);
        if (redisIdx !== -1 && redisIdx < targetIdx) {
          dmg = Math.floor(dmg * 0.7);
          addLog(`ğŸ”´ Redis ìºì‹œ ë³´í˜¸! ë°ë¯¸ì§€ -30%`, 'info');
        }
      }
      
      // ELB: ì„œë²„ 2ê°œ ì´ìƒì´ë©´ ë°ë¯¸ì§€ ë¶„ì‚° (50%)
      if (field.some(c => c.id === 'elb') && field.filter(c => c.category === 'computing').length >= 2) {
        dmg = Math.floor(dmg * 0.5);
        addLog(`âš–ï¸ ELB ë¶€í•˜ ë¶„ì‚°! ë°ë¯¸ì§€ -50%`, 'info');
      }
      
      return Math.max(0, dmg);
    }

    function attackWith(index) {
      const card = game.player.field[index];
      if (!card || !card.canAttack || game.turn !== 'player') return;

      card.canAttack = false;
      game.combo++;
      
      // ì´ ê³µê²©ë ¥ (ê¸°ë³¸ + ë³´ë„ˆìŠ¤ + ì½¤ë³´)
      const totalAtk = card.attack + (card.bonusAtk || 0) + (game.combo > 1 ? game.combo * 2 : 0);
      
      // ê³µê²© ì• ë‹ˆë©”ì´ì…˜
      showAttackAnimation(index, 'player');

      if (game.enemy.field.length > 0) {
        const target = game.enemy.field[0];
        target.currentHp -= totalAtk;
        
        const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
        addLog(`${card.icon} â†’ ${target.icon} (${totalAtk})${comboText}`, 'damage');
        showDamageNumber(totalAtk, 'enemy');
        
        if (target.currentHp <= 0) {
          game.enemy.field.shift();
          addLog(`${target.icon} íŒŒê´´!`, 'damage');
        }
      } else {
        game.enemy.hp = Math.max(0, game.enemy.hp - totalAtk);
        const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
        addLog(`${card.icon} ì§ì ‘ ê³µê²©! (${totalAtk})${comboText}`, 'damage');
        showDamageNumber(totalAtk, 'enemy-hp');
      }

      checkGameOver();
      updateBattleUI();
    }

    // ê³µê²© ì• ë‹ˆë©”ì´ì…˜
    function showAttackAnimation(index, side) {
      const field = document.getElementById(side === 'player' ? 'playerField' : 'enemyField');
      const cards = field.querySelectorAll('.field-card');
      if (cards[index]) {
        cards[index].classList.add('attacking');
        setTimeout(() => cards[index].classList.remove('attacking'), 300);
      }
    }

    // ë°ë¯¸ì§€ ìˆ«ì í‘œì‹œ
    function showDamageNumber(dmg, target) {
      const el = document.createElement('div');
      el.className = 'damage-number';
      el.textContent = `-${dmg}`;
      el.style.cssText = `
        position: fixed;
        top: ${target === 'enemy-hp' ? '15%' : '40%'};
        left: 50%;
        transform: translateX(-50%);
        font-size: 1.5em;
        font-weight: bold;
        color: #e74c3c;
        text-shadow: 0 0 10px #e74c3c;
        animation: floatUp 1s forwards;
        z-index: 1000;
        pointer-events: none;
      `;
      document.body.appendChild(el);
      setTimeout(() => el.remove(), 1000);
    }

    function endTurn() {
      if (game.turn !== 'player') return;
      game.turn = 'enemy';
      document.getElementById('endTurnBtn').disabled = true;
      updateBattleUI();
      setTimeout(enemyTurn, 1000);
    }

    // ì  ê³µê²© ëª©ë¡ ì¤€ë¹„
    function prepareNextEnemyAttack() {
      const attacks = [
        { name: 'DDoS', icon: 'ğŸ’¥', dmg: 50, type: 'normal' },
        { name: 'íŠ¸ë˜í”½ ìŠ¤íŒŒì´í¬', icon: 'ğŸ“ˆ', dmg: 30, type: 'spike', blockedBy: 'cdn' },
        { name: 'SQL Injection', icon: 'ğŸ’‰', dmg: 80, type: 'sql', blockedBy: 'waf' },
        { name: 'MITM ê³µê²©', icon: 'ğŸ‘¤', dmg: 40, type: 'mitm', blockedBy: 'ssl' },
        { name: 'ê¶Œí•œ ìƒìŠ¹', icon: 'ğŸ‘‘', dmg: 60, type: 'priv', blockedBy: 'iam' },
        { name: 'ë°ì´í„° ìœ ì¶œ', icon: 'ğŸ“¤', dmg: 45, type: 'leak', blockedBy: 'kms' },
        { name: 'ìŠ¤í…”ìŠ¤ ê³µê²©', icon: 'ğŸ‘»', dmg: 35, type: 'stealth', blockedBy: 'cloudwatch' }
      ];
      
      // ë‚œì´ë„ë³„ ê³µê²©ë ¥ ì¡°ì •
      const mod = game.settings?.atkMod || 1;
      game.nextEnemyAttack = attacks[Math.floor(Math.random() * attacks.length)];
      game.nextEnemyAttack.dmg = Math.floor(game.nextEnemyAttack.dmg * mod);
    }

    function enemyTurn() {
      game.enemy.mana++;
      const settings = game.settings || { spawnRate: 0.2, atkMod: 1 };
      
      // 1. ì  ìœ ë‹› ë°°ì¹˜ (ë‚œì´ë„ë³„ í™•ë¥ )
      if (Math.random() < settings.spawnRate && game.enemy.mana >= 2) {
        const cards = enemyCards[game.difficulty] || enemyCards.normal;
        const card = cards[Math.floor(Math.random() * cards.length)];
        game.enemy.field.push({ ...card, currentHp: card.hp });
        game.enemy.mana -= 2;
        addLog(`ğŸš¨ ì  ${card.icon} ${card.name} ë“±ì¥!`, 'damage');
        updateBattleUI();
      }

      // 2. ì  ìœ ë‹› ê³µê²©
      setTimeout(() => {
        game.enemy.field.forEach(enemyCard => {
          if (game.player.field.length > 0) {
            const target = game.player.field[0];
            const dmg = calculateDamageReduction(enemyCard.attack, target);
            target.currentHp -= dmg;
            addLog(`${enemyCard.icon} â†’ ${target.icon} (${dmg})`, 'damage');
            showDamageNumber(dmg, 'player');
            
            if (target.currentHp <= 0) {
              handleCardDestruction(target, game.player.field);
            }
          } else {
            game.player.hp = Math.max(0, game.player.hp - enemyCard.attack);
            addLog(`${enemyCard.icon} ì§ì ‘ ê³µê²©! (${enemyCard.attack})`, 'damage');
          }
        });
        
        updateBattleUI();
        checkGameOver();

        // 3. íŠ¹ìˆ˜ ê³µê²© (prepared attack)
        setTimeout(() => {
          if (game.nextEnemyAttack) {
            executeEnemyAttack(game.nextEnemyAttack);
          }
          
          // Hard ëª¨ë“œ: 2ë²ˆì§¸ ê³µê²©
          if (game.settings.doubleAttack && game.turnCount > 3) {
            prepareNextEnemyAttack();
            setTimeout(() => {
              addLog(`âš ï¸ ì—°ì† ê³µê²©!`, 'damage');
              executeEnemyAttack(game.nextEnemyAttack);
              finishEnemyTurn();
            }, 400);
          } else {
            finishEnemyTurn();
          }
        }, 600);
      }, 400);
    }

    function finishEnemyTurn() {
      prepareNextEnemyAttack();
      
      // Prometheus íš¨ê³¼: ë‹¤ìŒ ê³µê²© ë¯¸ë¦¬ë³´ê¸°
      if (game.player.field.some(c => c.id === 'prometheus')) {
        addLog(`ğŸ“ˆ ë‹¤ìŒ ê³µê²© ì˜ˆê³ : ${game.nextEnemyAttack.icon} ${game.nextEnemyAttack.name}`, 'info');
      }
      
      checkGameOver();
      setTimeout(startPlayerTurn, 500);
    }

    function executeEnemyAttack(atk) {
      let dmg = atk.dmg;
      let blocked = false;

      // íŠ¹ìˆ˜ ë°©ì–´ ì²´í¬
      if (atk.blockedBy && game.player.field.some(c => c.id === atk.blockedBy)) {
        const blocker = game.player.field.find(c => c.id === atk.blockedBy);
        addLog(`${blocker.icon} ${blocker.name}ì´(ê°€) ${atk.name} ì°¨ë‹¨!`, 'info');
        blocked = true;
      }

      if (!blocked) {
        // ë°ë¯¸ì§€ ê°ì†Œ ì ìš©
        const target = game.player.field[0] || null;
        dmg = calculateDamageReduction(dmg, target);

        if (game.player.field.length > 0) {
          target.currentHp -= dmg;
          addLog(`${atk.icon} ${atk.name} â†’ ${target.icon} (${dmg})`, 'damage');
          showDamageNumber(dmg, 'player');
          
          if (target.currentHp <= 0) {
            handleCardDestruction(target, game.player.field);
          }
        } else {
          game.player.hp = Math.max(0, game.player.hp - dmg);
          addLog(`${atk.icon} ${atk.name}! (${dmg})`, 'damage');
          showDamageNumber(dmg, 'player-hp');
        }
      }
      
      updateBattleUI();
    }

    // ì¹´ë“œ íŒŒê´´ ì²˜ë¦¬ (íŠ¹ìˆ˜ íš¨ê³¼)
    function handleCardDestruction(card, field) {
      const idx = field.findIndex(c => c.uid === card.uid);
      if (idx === -1) return;

      // K8s: 50% í™•ë¥  ë¶€í™œ
      if (card.id === 'k8s' && Math.random() < 0.5) {
        card.currentHp = Math.floor(card.hp * 0.3);
        addLog(`â˜¸ï¸ K8s Pod ë¶€í™œ! (HP ${card.currentHp})`, 'info');
        return;
      }

      // Terraform: í•¸ë“œì— ë³µì‚¬ë³¸ ì¶”ê°€
      if (card.id === 'terraform' && game.player.hand.length < 7) {
        const copy = allCards.find(c => c.id === 'terraform');
        game.player.hand.push({ ...copy, uid: Date.now() + Math.random() });
        addLog(`ğŸ—ï¸ Terraform IaC ì¬ìƒì„±!`, 'info');
      }

      // S3: ëª¨ë“  ì•„êµ° HP +20
      if (card.id === 's3') {
        field.forEach(c => {
          if (c.uid !== card.uid) {
            c.currentHp = Math.min(c.hp, c.currentHp + 20);
          }
        });
        addLog(`ğŸª£ S3 ë°±ì—… ë³µì›! ëª¨ë“  ì•„êµ° HP +20`, 'info');
      }

      field.splice(idx, 1);
      addLog(`${card.icon} íŒŒê´´!`, 'damage');
    }

    function startPlayerTurn() {
      game.turn = 'player';
      game.turnCount++;
      
      // ë§ˆë‚˜ ì¦ê°€
      game.maxMana = Math.min(10, game.turnCount);
      game.mana = game.maxMana;
      game.combo = 0; // ì½¤ë³´ ë¦¬ì…‹

      // ë“œë¡œìš° (hardëŠ” 2í„´ì— 1ì¥)
      if (game.settings.drawRate === 1 || game.turnCount % 2 === 1) {
        drawCard();
      } else {
        addLog(`âš ï¸ ì´ë²ˆ í„´ ë“œë¡œìš° ì—†ìŒ`, 'info');
      }

      // RDS íšŒë³µ
      game.player.field.forEach(c => {
        if (c.id === 'rds') {
          c.currentHp = Math.min(c.hp, c.currentHp + 5);
          addLog(`ğŸ—„ï¸ RDS ìë™ íšŒë³µ +5`, 'info');
        }
      });

      // CI/CD ì¶”ê°€ ë“œë¡œìš°
      if (game.player.field.some(c => c.id === 'cicd')) {
        drawCard();
        addLog('ğŸ”„ CI/CD ì¶”ê°€ ë“œë¡œìš°!', 'info');
      }

      // ì‹œë„ˆì§€ ì¬ê³„ì‚°
      applySynergyEffects();

      game.player.field.forEach(c => c.canAttack = true);
      document.getElementById('endTurnBtn').disabled = false;
      
      // 5í„´ë§ˆë‹¤ ì´ë²¤íŠ¸
      if (game.turnCount % 5 === 0) {
        triggerRandomEvent();
      }
      
      addLog(`--- í„´ ${game.turnCount} ---`, 'info');
      updateBattleUI();
    }

    // ëœë¤ ì´ë²¤íŠ¸
    function triggerRandomEvent() {
      const events = [
        { name: 'íŠ¸ë˜í”½ ê¸‰ì¦', effect: () => { game.enemy.hp = Math.max(0, game.enemy.hp - 15); addLog('ğŸ“Š íŠ¸ë˜í”½ ê¸‰ì¦! ì  ì„œë²„ ê³¼ë¶€í•˜ (-15 HP)', 'info'); }},
        { name: 'í´ë¼ìš°ë“œ í¬ë ˆë”§', effect: () => { game.mana += 2; addLog('ğŸ’° í´ë¼ìš°ë“œ í¬ë ˆë”§ ì§€ê¸‰! ë§ˆë‚˜ +2', 'info'); }},
        { name: 'ë³´ì•ˆ íŒ¨ì¹˜', effect: () => { game.player.field.forEach(c => c.currentHp = Math.min(c.hp, c.currentHp + 10)); addLog('ğŸ”’ ë³´ì•ˆ íŒ¨ì¹˜ ì ìš©! ëª¨ë“  ìœ ë‹› HP +10', 'info'); }},
        { name: 'ì˜¤í† ìŠ¤ì¼€ì¼ë§', effect: () => { drawCard(); drawCard(); addLog('ğŸ“ˆ ì˜¤í† ìŠ¤ì¼€ì¼ë§! ì¹´ë“œ 2ì¥ ë“œë¡œìš°', 'info'); }}
      ];
      const event = events[Math.floor(Math.random() * events.length)];
      addLog(`âš¡ ì´ë²¤íŠ¸: ${event.name}`, 'info');
      event.effect();
    }

    function checkGameOver() {
      if (game.enemy.hp <= 0) {
        setTimeout(() => showGameOver(true), 300);
      } else if (game.player.hp <= 0) {
        setTimeout(() => showGameOver(false), 300);
      }
    }

    function showGameOver(win) {
      // í†µê³„ ì—…ë°ì´íŠ¸
      if (win) {
        game.stats.wins++;
        if (game.turnCount < game.stats.fastestWin) {
          game.stats.fastestWin = game.turnCount;
        }
      } else {
        game.stats.losses++;
      }
      saveStats();

      const el = document.getElementById('gameOver');
      el.className = 'game-over active ' + (win ? 'win' : 'lose');
      
      const statsText = `ì „ì : ${game.stats.wins}ìŠ¹ ${game.stats.losses}íŒ¨ | ìµœë‹¨ í´ë¦¬ì–´: ${game.stats.fastestWin === 999 ? '-' : game.stats.fastestWin + 'í„´'}`;
      
      document.getElementById('gameOverTitle').textContent = win ? 'ğŸ‰ ìŠ¹ë¦¬!' : 'ğŸ’€ íŒ¨ë°°';
      document.getElementById('gameOverMsg').innerHTML = `
        ${win ? 'ì„œë²„ë¥¼ ë‹¤ìš´ì‹œì¼°ìŠµë‹ˆë‹¤!' : 'ì„œë²„ê°€ ë‹¤ìš´ë˜ì—ˆìŠµë‹ˆë‹¤...'}<br>
        <small style="color: #888;">${game.turnCount}í„´ ì†Œìš” | ${statsText}</small>
      `;
    }

    function restartGame() {
      document.getElementById('gameOver').className = 'game-over';
      exitGame();
    }

    function addLog(msg, type = '') {
      const log = document.getElementById('battleLog');
      const entry = document.createElement('div');
      entry.className = 'log-entry ' + type;
      entry.textContent = msg;
      log.appendChild(entry);
      log.scrollTop = log.scrollHeight;
      while (log.children.length > 15) log.removeChild(log.firstChild);
    }

    function updateBattleUI() {
      // HP (ì•„ë°”íƒ€ì— ìˆ«ìë§Œ í‘œì‹œ)
      const pPct = (game.player.hp / game.player.maxHp) * 100;
      const ePct = (game.enemy.hp / game.enemy.maxHp) * 100;
      
      document.getElementById('playerHpFill').style.width = pPct + '%';
      document.getElementById('playerHpFill').className = 'hp-fill' + (pPct < 30 ? ' low' : '');
      document.getElementById('playerHpText').textContent = game.player.hp;
      
      document.getElementById('enemyHpFill').style.width = ePct + '%';
      document.getElementById('enemyHpFill').className = 'hp-fill' + (ePct < 30 ? ' low' : '');
      document.getElementById('enemyHpText').textContent = game.enemy.hp;

      document.getElementById('manaText').textContent = `${game.mana}/${game.maxMana}`;

      // í•¸ë“œ
      const hand = document.getElementById('playerHand');
      hand.innerHTML = game.player.hand.map((card, i) => {
        const canPlay = card.cost <= game.mana;
        const rot = (i - (game.player.hand.length - 1) / 2) * 5;
        return `
          <div class="hand-card ${!canPlay ? 'disabled' : 'playable'}" 
               style="transform: rotate(${rot}deg);"
               data-index="${i}">
            <span class="cost">${card.cost}</span>
            <span class="icon">${card.icon}</span>
            <span class="name">${card.name}</span>
            <span class="card-stats">
              <span style="color:#e74c3c">âš”${card.attack}</span>
              <span style="color:#2ecc71">â¤${card.hp}</span>
            </span>
          </div>
        `;
      }).join('');

      // í”Œë ˆì´ì–´ í•„ë“œ
      const pField = document.getElementById('playerField');
      pField.innerHTML = game.player.field.length > 0
        ? game.player.field.map((card, i) => {
            const totalAtk = card.attack + (card.bonusAtk || 0);
            const hasBonus = card.bonusAtk > 0;
            return `
            <div class="field-card ${card.canAttack ? 'can-attack' : ''} ${hasBonus ? 'synergy' : ''}" 
                 data-field-index="${i}" data-card-id="${card.id}">
              <span class="icon">${card.icon}</span>
              <span class="name">${card.name}</span>
              <span class="card-atk" ${hasBonus ? 'style="background:linear-gradient(135deg,#f39c12,#d68910)"' : ''}>${totalAtk}</span>
              <span class="card-hp">${card.currentHp}</span>
            </div>
          `}).join('')
        : '';

      // ì  í•„ë“œ
      const eField = document.getElementById('enemyField');
      eField.innerHTML = game.enemy.field.length > 0
        ? game.enemy.field.map((card, i) => `
            <div class="field-card" data-enemy-index="${i}" data-card-id="${card.id}">
              <span class="icon">${card.icon}</span>
              <span class="name">${card.name}</span>
              <span class="card-atk">${card.attack}</span>
              <span class="card-hp">${card.currentHp}</span>
            </div>
          `).join('')
        : '';

      bindHandCardEvents();
      bindFieldCardEvents();
      updateEndTurnButton();
    }

    // í„´ ì¢…ë£Œ ë²„íŠ¼ í•˜ì´ë¼ì´íŠ¸ (í•  ë™ì‘ ì—†ì„ ë•Œë§Œ)
    function updateEndTurnButton() {
      const btn = document.getElementById('endTurnBtn');
      if (!btn || game.turn !== 'player') {
        btn?.classList.remove('highlight');
        return;
      }

      // ë°°ì¹˜ ê°€ëŠ¥í•œ ì¹´ë“œ ìˆëŠ”ì§€
      const canPlayCard = game.player.hand.some(c => c.cost <= game.mana);
      
      // ê³µê²© ê°€ëŠ¥í•œ ì¹´ë“œ ìˆëŠ”ì§€
      const canAttack = game.player.field.some(c => c.canAttack);
      
      // ë‘˜ ë‹¤ ì—†ìœ¼ë©´ í•˜ì´ë¼ì´íŠ¸
      if (!canPlayCard && !canAttack) {
        btn.classList.add('highlight');
      } else {
        btn.classList.remove('highlight');
      }
    }

    // í•„ë“œ ì¹´ë“œ ì´ë²¤íŠ¸ (íƒ­=ì„¤ëª…, ë“œë˜ê·¸=ê³µê²©)
    let attackDragState = { active: false, cardIndex: null, startX: 0, startY: 0 };

    function bindFieldCardEvents() {
      // í”Œë ˆì´ì–´ í•„ë“œ ì¹´ë“œ
      document.querySelectorAll('#playerField .field-card[data-field-index]').forEach(el => {
        const fieldIndex = parseInt(el.dataset.fieldIndex);
        let startTime = 0;
        let moved = false;
        let touchStarted = false;

        el.addEventListener('touchstart', (e) => {
          e.preventDefault();
          const card = game.player.field[fieldIndex];
          
          startTime = Date.now();
          moved = false;
          touchStarted = true;
          
          if (card) {
            const touch = e.touches[0];
            // ê³µê²© ê°€ëŠ¥ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ íƒ­ ê°ì§€, ë“œë˜ê·¸ëŠ” ê³µê²© ê°€ëŠ¥í•  ë•Œë§Œ
            attackDragState = { 
              active: false, 
              cardIndex: fieldIndex, 
              startX: touch.clientX, 
              startY: touch.clientY,
              canAttack: card.canAttack && game.turn === 'player'
            };
          }
        });

        el.addEventListener('touchmove', (e) => {
          if (attackDragState.cardIndex !== fieldIndex) return;
          const touch = e.touches[0];
          const dx = Math.abs(touch.clientX - attackDragState.startX);
          const dy = Math.abs(touch.clientY - attackDragState.startY);
          
          if (dx > 10 || dy > 10) {
            moved = true;
            // ê³µê²© ê°€ëŠ¥í•  ë•Œë§Œ ë“œë˜ê·¸ ê³µê²© UI í‘œì‹œ
            if (attackDragState.canAttack) {
              attackDragState.active = true;
              el.classList.add('attacking-source');
              showAttackTargets();
              updateAttackArrow(touch.clientX, touch.clientY);
            }
          }
        });

        el.addEventListener('touchend', (e) => {
          if (!touchStarted) return;
          touchStarted = false;
          
          if (!moved && Date.now() - startTime < 300) {
            // íƒ­ = ì„¤ëª… í‘œì‹œ (ê³µê²© ê°€ëŠ¥ ì—¬ë¶€ ë¬´ê´€)
            const card = game.player.field[fieldIndex];
            if (card) showFieldCardInfo(card);
          } else if (attackDragState.active && attackDragState.cardIndex === fieldIndex) {
            // ë“œë˜ê·¸ = ê³µê²©
            const touch = e.changedTouches[0];
            executeAttackOnTarget(fieldIndex, touch.clientX, touch.clientY);
          }
          
          el.classList.remove('attacking-source');
          hideAttackTargets();
          attackDragState = { active: false, cardIndex: null, startX: 0, startY: 0 };
        });

        // PC: í´ë¦­=ì„¤ëª…
        el.addEventListener('click', (e) => {
          if (e.detail === 1) {
            setTimeout(() => {
              if (!attackDragState.active) {
                const card = game.player.field[fieldIndex];
                if (card) showFieldCardInfo(card);
              }
            }, 200);
          }
        });
      });

      // ì  í•„ë“œ ì¹´ë“œ (íƒ­=ì„¤ëª…)
      document.querySelectorAll('#enemyField .field-card[data-enemy-index]').forEach(el => {
        el.addEventListener('click', () => {
          const idx = parseInt(el.dataset.enemyIndex);
          const card = game.enemy.field[idx];
          if (card) showFieldCardInfo(card);
        });
        el.addEventListener('touchend', (e) => {
          e.preventDefault();
          const idx = parseInt(el.dataset.enemyIndex);
          const card = game.enemy.field[idx];
          if (card) showFieldCardInfo(card);
        });
      });
    }

    // ê³µê²© ëŒ€ìƒ í•˜ì´ë¼ì´íŠ¸
    function showAttackTargets() {
      document.querySelectorAll('#enemyField .field-card').forEach(el => {
        el.classList.add('attack-target');
      });
      document.getElementById('enemyAvatar')?.classList.add('attack-target');
    }

    function hideAttackTargets() {
      document.querySelectorAll('.attack-target').forEach(el => {
        el.classList.remove('attack-target');
      });
      const arrow = document.getElementById('attackArrow');
      if (arrow) arrow.style.display = 'none';
    }

    function updateAttackArrow(x, y) {
      let arrow = document.getElementById('attackArrow');
      if (!arrow) {
        arrow = document.createElement('div');
        arrow.id = 'attackArrow';
        arrow.style.cssText = `
          position: fixed; pointer-events: none; z-index: 1000;
          width: 20px; height: 20px; border-radius: 50%;
          background: radial-gradient(circle, #e74c3c, transparent);
          box-shadow: 0 0 20px #e74c3c;
          transform: translate(-50%, -50%);
        `;
        document.body.appendChild(arrow);
      }
      arrow.style.display = 'block';
      arrow.style.left = x + 'px';
      arrow.style.top = y + 'px';

      // íƒ€ê²Ÿ í•˜ì´ë¼ì´íŠ¸ ì—…ë°ì´íŠ¸
      document.querySelectorAll('.field-card.attack-target').forEach(el => el.classList.remove('attack-target'));
      
      // ì  ì¹´ë“œ ìœ„ì— ìˆìœ¼ë©´ í•˜ì´ë¼ì´íŠ¸
      document.querySelectorAll('#enemyField .field-card').forEach(el => {
        const rect = el.getBoundingClientRect();
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          el.classList.add('attack-target');
        }
      });
    }

    function executeAttackOnTarget(attackerIndex, x, y) {
      const card = game.player.field[attackerIndex];
      if (!card || !card.canAttack || game.turn !== 'player') return;

      // ì  ìœ ë‹› íƒ€ê²Ÿ ì²´í¬
      const enemyCards = document.querySelectorAll('#enemyField .field-card');
      for (let i = 0; i < enemyCards.length; i++) {
        const rect = enemyCards[i].getBoundingClientRect();
        if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
          attackEnemyCard(attackerIndex, i);
          return;
        }
      }

      // ì  HP ì§ì ‘ ê³µê²© ì²´í¬
      const hpBar = document.getElementById('enemyAvatar');
      if (hpBar) {
        const rect = hpBar.getBoundingClientRect();
        if (x >= rect.left - 50 && x <= rect.right + 50 && y >= rect.top - 30 && y <= rect.bottom + 30) {
          if (game.enemy.field.length === 0) {
            attackDirectly(attackerIndex);
          } else {
            addLog('âš ï¸ ì  ìœ ë‹›ì´ ìˆì–´ ì§ì ‘ ê³µê²© ë¶ˆê°€!', 'info');
          }
          return;
        }
      }
    }

    function attackEnemyCard(attackerIndex, targetIndex) {
      const attacker = game.player.field[attackerIndex];
      const target = game.enemy.field[targetIndex];
      if (!attacker || !target || !attacker.canAttack) return;

      attacker.canAttack = false;
      game.combo++;
      
      const totalAtk = attacker.attack + (attacker.bonusAtk || 0) + (game.combo > 1 ? game.combo * 2 : 0);
      target.currentHp -= totalAtk;
      
      showAttackAnimation(attackerIndex, 'player');
      const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
      addLog(`${attacker.icon} â†’ ${target.icon} (${totalAtk})${comboText}`, 'damage');
      showDamageNumber(totalAtk, 'enemy');
      
      if (target.currentHp <= 0) {
        game.enemy.field.splice(targetIndex, 1);
        addLog(`${target.icon} íŒŒê´´!`, 'damage');
      }
      
      checkGameOver();
      updateBattleUI();
    }

    function attackDirectly(attackerIndex) {
      const attacker = game.player.field[attackerIndex];
      if (!attacker || !attacker.canAttack) return;

      attacker.canAttack = false;
      game.combo++;
      
      const totalAtk = attacker.attack + (attacker.bonusAtk || 0) + (game.combo > 1 ? game.combo * 2 : 0);
      game.enemy.hp = Math.max(0, game.enemy.hp - totalAtk);
      
      showAttackAnimation(attackerIndex, 'player');
      const comboText = game.combo > 1 ? ` (${game.combo}ì½¤ë³´!)` : '';
      addLog(`${attacker.icon} ì§ì ‘ ê³µê²©! (${totalAtk})${comboText}`, 'damage');
      showDamageNumber(totalAtk, 'enemy-hp');
      
      checkGameOver();
      updateBattleUI();
    }

    // í•„ë“œ ì¹´ë“œ ì •ë³´ í‘œì‹œ
    function showFieldCardInfo(card) {
      document.getElementById('gameCardIcon').textContent = card.icon;
      document.getElementById('gameCardName').textContent = card.name;
      document.getElementById('gameCardCategory').textContent = getCategoryName(card.category || 'attack');
      document.getElementById('gameCardCost').textContent = card.cost || '-';
      document.getElementById('gameCardHp').textContent = card.currentHp || card.hp;
      document.getElementById('gameCardAtk').textContent = (card.attack || 0) + (card.bonusAtk || 0);
      document.getElementById('gameCardDesc').textContent = card.desc || 'ì  ìœ ë‹›';
      document.getElementById('gameCardEffect').textContent = 'ğŸ’¡ ' + (card.effect || 'ê³µê²© ìœ ë‹›');
      document.getElementById('gameCardActions').innerHTML = `
        <button class="btn btn-danger" onclick="closeGameCardModal()">ë‹«ê¸°</button>
      `;
      document.getElementById('gameCardModal').classList.add('active');
    }

    // ========== ë“œë˜ê·¸ ì‹œìŠ¤í…œ (í•¸ë“œ ì¹´ë“œ) ==========
    let dragState = { active: false, cardIndex: null, startX: 0, startY: 0, startTime: 0 };

    function bindHandCardEvents() {
      const cards = document.querySelectorAll('#playerHand .hand-card');
      cards.forEach((card, index) => {
        card.addEventListener('touchstart', (e) => startHandDrag(e, index), { passive: false });
        card.addEventListener('mousedown', (e) => startHandDrag(e, index));
      });
    }

    function startHandDrag(e, index) {
      const card = game.player.hand[index];
      if (!card) return;

      e.preventDefault();
      const touch = e.touches ? e.touches[0] : e;
      
      dragState.startX = touch.clientX;
      dragState.startY = touch.clientY;
      dragState.cardIndex = index;
      dragState.startTime = Date.now();
      dragState.active = false;

      document.addEventListener('touchmove', onHandDragMove, { passive: false });
      document.addEventListener('touchend', onHandDragEnd);
      document.addEventListener('mousemove', onHandDragMove);
      document.addEventListener('mouseup', onHandDragEnd);
    }

    function onHandDragMove(e) {
      e.preventDefault();
      const touch = e.touches ? e.touches[0] : e;
      const dx = touch.clientX - dragState.startX;
      const dy = touch.clientY - dragState.startY;

      // ë“œë˜ê·¸ ì‹œì‘ (ì›€ì§ì„ ê°ì§€)
      if (!dragState.active && (Math.abs(dx) > 15 || Math.abs(dy) > 15)) {
        const card = game.player.hand[dragState.cardIndex];
        if (card && card.cost <= game.mana) {
          dragState.active = true;
          showDragGhost(dragState.cardIndex, touch.clientX, touch.clientY);
          const cards = document.querySelectorAll('#playerHand .hand-card');
          if (cards[dragState.cardIndex]) cards[dragState.cardIndex].classList.add('dragging');
        }
      }

      if (dragState.active) {
        moveDragGhost(touch.clientX, touch.clientY);
        checkDropTarget(touch.clientX, touch.clientY);
      }
    }

    function onHandDragEnd(e) {
      document.removeEventListener('touchmove', onHandDragMove);
      document.removeEventListener('touchend', onHandDragEnd);
      document.removeEventListener('mousemove', onHandDragMove);
      document.removeEventListener('mouseup', onHandDragEnd);

      const elapsed = Date.now() - dragState.startTime;

      if (dragState.active) {
        // ë“œë˜ê·¸ â†’ ë°°ì¹˜ ì‹œë„
        const touch = e.changedTouches ? e.changedTouches[0] : e;
        tryDrop(touch.clientX, touch.clientY);
        hideDragGhost();
        document.querySelectorAll('#playerHand .hand-card').forEach(c => c.classList.remove('dragging'));
        document.getElementById('playerField').classList.remove('drop-target');
      } else if (elapsed < 300) {
        // ì§§ì€ íƒ­ â†’ ì„¤ëª… í‘œì‹œ
        const card = game.player.hand[dragState.cardIndex];
        if (card) showHandCardInfo(card, dragState.cardIndex);
      }

      dragState.active = false;
      dragState.cardIndex = null;
    }

    // í•¸ë“œ ì¹´ë“œ ì •ë³´ í‘œì‹œ (ë°°ì¹˜ ë²„íŠ¼ í¬í•¨)
    function showHandCardInfo(card, handIndex) {
      document.getElementById('gameCardIcon').textContent = card.icon;
      document.getElementById('gameCardName').textContent = card.name;
      document.getElementById('gameCardCategory').textContent = getCategoryName(card.category);
      document.getElementById('gameCardCost').textContent = card.cost;
      document.getElementById('gameCardHp').textContent = card.hp;
      document.getElementById('gameCardAtk').textContent = card.attack;
      document.getElementById('gameCardDesc').textContent = card.desc;
      document.getElementById('gameCardEffect').textContent = 'ğŸ’¡ ' + card.effect;
      
      const canPlay = card.cost <= game.mana;
      document.getElementById('gameCardActions').innerHTML = `
        <button class="btn btn-primary" ${canPlay ? '' : 'disabled'} onclick="playCardFromModal(${handIndex})">
          ${canPlay ? 'âš¡ ë°°ì¹˜' : 'ë§ˆë‚˜ ë¶€ì¡±'}
        </button>
        <button class="btn btn-danger" onclick="closeGameCardModal()">ë‹«ê¸°</button>
      `;
      document.getElementById('gameCardModal').classList.add('active');
      game.selectedIndex = handIndex;
    }

    function playCardFromModal(index) {
      game.selectedIndex = index;
      playSelectedCard();
    }

    function showDragGhost(index, x, y) {
      const card = game.player.hand[index];
      const ghost = document.getElementById('dragGhost');
      ghost.innerHTML = `
        <div class="hand-card">
          <span class="cost">${card.cost}</span>
          <span class="icon">${card.icon}</span>
          <span class="name">${card.name}</span>
        </div>
      `;
      ghost.style.left = x + 'px';
      ghost.style.top = y + 'px';
      ghost.style.display = 'block';
    }

    function moveDragGhost(x, y) {
      const ghost = document.getElementById('dragGhost');
      ghost.style.left = x + 'px';
      ghost.style.top = y + 'px';
    }

    function hideDragGhost() {
      document.getElementById('dragGhost').style.display = 'none';
    }

    function checkDropTarget(x, y) {
      const field = document.getElementById('playerField');
      const rect = field.getBoundingClientRect();
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        field.classList.add('drop-target');
      } else {
        field.classList.remove('drop-target');
      }
    }

    function tryDrop(x, y) {
      const field = document.getElementById('playerField');
      const rect = field.getBoundingClientRect();
      if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
        const card = game.player.hand[dragState.cardIndex];
        if (game.player.field.length >= 6) {
          addLog('âš ï¸ í•„ë“œê°€ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤! (ìµœëŒ€ 6ì¥)', 'info');
          return;
        }
        if (card && card.cost <= game.mana) {
          game.mana -= card.cost;
          const newCard = { ...card, currentHp: card.hp, canAttack: false, bonusAtk: 0 };
          
          // Fargate ì¦‰ì‹œ ê³µê²© ê°€ëŠ¥
          if (card.id === 'fargate') {
            newCard.canAttack = true;
            addLog(`ğŸš€ Fargate ì¦‰ì‹œ ë°°ì¹˜!`, 'info');
          }
          
          game.player.field.push(newCard);
          game.player.hand.splice(dragState.cardIndex, 1);
          
          // ì‹œë„ˆì§€ íš¨ê³¼ ì ìš©
          applySynergyEffects();
          
          addLog(`${card.icon} ${card.name} ë°°ì¹˜!`, 'info');
          updateBattleUI();
        }
      }
    }

    // ========== ì´ˆê¸°í™” ==========
    document.querySelectorAll('.tab-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
        btn.classList.add('active');
        document.getElementById(btn.dataset.tab).classList.add('active');
      });
    });

    // ë± í•„í„° ë²„íŠ¼ ì´ë²¤íŠ¸
    document.querySelectorAll('.deck-filter-btn').forEach(btn => {
      btn.addEventListener('click', () => {
        document.querySelectorAll('.deck-filter-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        currentDeckFilter = btn.dataset.deck;
        currentCategoryFilter = 'all';
        updateCategoryFilters(currentDeckFilter);
        renderCardGrid();
      });
    });

    // ì´ˆê¸° ë Œë”ë§
    updateCategoryFilters('all');
    renderCardGrid();
  </script>
</body>
</html>
